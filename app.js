// === app.js === (Version 2.8.6 - UI Refinements, Tab Merge, Data Import) ===

// --- Core Imports ---
import { bdsmData } from './data.js';
import { getStyleBreakdown as getSubBreakdown } from './paraphrasing_sub.js';
import { getStyleBreakdown as getDomBreakdown } from './paraphrasing_dom.js';
import { glossaryTerms } from './glossary.js';
import { getRandomPrompt } from './prompts.js';
import { achievementList, hasAchievement, grantAchievement, getAchievementDetails } from './achievements.js';

// --- New Feature Imports ---
import { synergyHints, findHintsForTraits } from './synergyHints.js'; // Assuming findHintsForTraits is exported
import { goalKeywords } from './goalPrompts.js';
import { challenges } from './challenges.js';
import { oracleReadings } from './oracle.js';

// --- Style Finder Data Import ---
import {
    sfStyles,
    sfSubFinderTraits,
    sfSubTraitFootnotes,
    sfDomFinderTraits,
    sfDomTraitFootnotes,
    sfSliderDescriptions,
    sfTraitExplanations,
    sfStyleDescriptions,
    sfDynamicMatches,
    sfStyleKeyTraits
} from './styleFinderData.js'; // <<< Ensure this file is correct and in the same folder

// Chart.js and Confetti loaded via CDN

// --- Top Level Data Check ---
console.log("--- Data Sanity Checks ---"); /* ... */ console.log("--- End Data Check ---");


const contextHelpTexts = { /* ... */ };

class TrackerApp {
  constructor() {
    console.log("[CONSTRUCTOR] STARTING KinkCompass App (v2.8.6)...");
    this.people = [];
    this.previewPerson = null;
    this.currentEditId = null;
    this.chartInstance = null;
    this.notificationTimer = null;
    // Default active tab reflects merged structure
    this.activeDetailModalTab = 'tab-traits-breakdown'; // <<< Default Merged Tab
    this.elementThatOpenedModal = null;
    this.lastSavedId = null;

    // --- Style Finder State ---
    this.styleFinderActive = false; this.styleFinderStep = 0; this.styleFinderRole = null; this.styleFinderAnswers = { traits: {} }; this.styleFinderScores = {}; this.hasRenderedDashboard = false; this.previousScores = null; this.styleFinderTraits = []; this.traitFootnotes = {}; this.sliderDescriptions = {}; this.sfSliderInteracted = false;

    console.log("[CONSTRUCTOR] Mapping elements...");
    this.elements = { /* ... (Same full mapping as before) ... */
        formSection: document.getElementById('form-section'), name: document.getElementById('name'), avatarDisplay: document.getElementById('avatar-display'), avatarInput: document.getElementById('avatar-input'), avatarPicker: document.querySelector('.avatar-picker'), role: document.getElementById('role'), style: document.getElementById('style'), styleExploreLink: document.getElementById('style-explore-link'), formStyleFinderLink: document.getElementById('form-style-finder-link'), traitsContainer: document.getElementById('traits-container'), traitsMessage: document.getElementById('traits-message'), traitInfoPopup: document.getElementById('trait-info-popup'), traitInfoClose: document.getElementById('trait-info-close'), traitInfoTitle: document.getElementById('trait-info-title'), traitInfoBody: document.getElementById('trait-info-body'), contextHelpPopup: document.getElementById('context-help-popup'), contextHelpClose: document.getElementById('context-help-close'), contextHelpTitle: document.getElementById('context-help-title'), contextHelpBody: document.getElementById('context-help-body'), save: document.getElementById('save'), clearForm: document.getElementById('clear-form'), peopleList: document.getElementById('people-list'), livePreview: document.getElementById('live-preview'), modal: document.getElementById('detail-modal'), modalBody: document.getElementById('modal-body'), modalTabs: document.getElementById('modal-tabs'), modalClose: document.getElementById('modal-close'), resourcesBtn: document.getElementById('resources-btn'), resourcesModal: document.getElementById('resources-modal'), resourcesClose: document.getElementById('resources-close'), resourcesBody: document.getElementById('resources-body'), glossaryBtn: document.getElementById('glossary-btn'), glossaryModal: document.getElementById('glossary-modal'), glossaryClose: document.getElementById('glossary-close'), glossaryBody: document.getElementById('glossary-body'), styleDiscoveryBtn: document.getElementById('style-discovery-btn'), styleDiscoveryModal: document.getElementById('style-discovery-modal'), styleDiscoveryClose: document.getElementById('style-discovery-close'), styleDiscoveryRoleFilter: document.getElementById('style-discovery-role'), styleDiscoveryBody: document.getElementById('style-discovery-body'), themesBtn: document.getElementById('themes-btn'), themesModal: document.getElementById('themes-modal'), themesClose: document.getElementById('themes-close'), themesBody: document.getElementById('themes-body'), achievementsBtn: document.getElementById('achievements-btn'), achievementsModal: document.getElementById('achievements-modal'), achievementsClose: document.getElementById('achievements-close'), achievementsBody: document.getElementById('achievements-body'), welcomeModal: document.getElementById('welcome-modal'), welcomeClose: document.getElementById('welcome-close'), exportBtn: document.getElementById('export-btn'), importBtn: document.getElementById('import-btn'), importFileInput: document.getElementById('import-file-input'), themeToggle: document.getElementById('theme-toggle'), styleFinderTriggerBtn: document.getElementById('style-finder-trigger-btn'), sfModal: document.getElementById('style-finder-modal'), sfCloseBtn: document.getElementById('sf-close-style-finder'), sfProgressTracker: document.getElementById('sf-progress-tracker'), sfStepContent: document.getElementById('sf-step-content'), sfFeedback: document.getElementById('sf-feedback'), sfDashboard: document.getElementById('sf-dashboard'), detailModalTitle: document.getElementById('detail-modal-title'), formTitle: document.getElementById('form-title'), dailyChallengeArea: document.getElementById('daily-challenge-area') // Target this inside preview card
    };
    console.log(`[CONSTRUCTOR] Elements mapped.`);

    // CRITICAL CHECK
    if (!this.elements.role || !this.elements.style) { console.error("[CONSTRUCTOR] CRITICAL ERROR: Role or Style dropdown missing!"); alert("App critical error."); return; }
    if (!this.elements.sfStepContent || !this.elements.sfModal) { console.warn("[CONSTRUCTOR] Style Finder UI elements missing."); }

    console.log("[CONSTRUCTOR] Calling addEventListeners...");
    this.addEventListeners();
    console.log("[CONSTRUCTOR] Listeners setup completed.");

    console.log("[CONSTRUCTOR] Loading data and initial render...");
    this.loadFromLocalStorage();
    this.applySavedTheme();
    this.renderStyles(this.elements.role.value);
    this.renderTraits(this.elements.role.value, this.elements.style.value);
    this.renderList();
    this.updateLivePreview();
    this.checkAndShowWelcome();
    // displayDailyChallenge now called within updateLivePreview
    console.log("[CONSTRUCTOR] Initial load and render finished.");
  } // --- End of constructor ---

  // --- Local Storage --- (Keep Functions as they were)
  loadFromLocalStorage() { console.log("[LOAD_STORAGE] Attempting load."); try { const data = localStorage.getItem('kinkCompassPeople'); if (data) { this.people = JSON.parse(data); console.log(`[LOAD_STORAGE] Loaded ${this.people.length}.`); this.people.forEach(p => { if (!p.id) p.id = Date.now() + Math.random(); if (!p.achievements) p.achievements = []; if (!p.goals) p.goals = []; if (!p.history) p.history = []; if (p.reflections === undefined) p.reflections = ""; }); } else { console.log("[LOAD_STORAGE] No data."); } } catch (error) { console.error("[LOAD_STORAGE] Error:", error); this.showNotification("Error loading data.", "error"); this.people = []; } }
  saveToLocalStorage() { console.log("[SAVE_STORAGE] Saving."); try { localStorage.setItem('kinkCompassPeople', JSON.stringify(this.people)); console.log(`[SAVE_STORAGE] Saved ${this.people.length}.`); } catch (error) { console.error("[SAVE_STORAGE] Error:", error); this.showNotification("Error saving.", "error"); } }

  // --- Onboarding --- (Keep Functions as they were)
  checkAndShowWelcome() { console.log("[WELCOME] Checking."); if (!localStorage.getItem('kinkCompassWelcomed')) { console.log("[WELCOME] First visit. Showing."); this.showWelcomeMessage(); } else { console.log("[WELCOME] Not first visit."); } }
  showWelcomeMessage() { console.log("[WELCOME] Opening modal."); if (this.elements.welcomeModal) { this.openModal(this.elements.welcomeModal); localStorage.setItem('kinkCompassWelcomed', 'true'); console.log("[WELCOME] Flag set."); } else { console.warn("[WELCOME] Modal element missing."); } }

  // --- Event Listeners Setup --- (Keep Function as it was)
  addEventListeners() { console.log("[ADD_LISTENERS] Starting setup..."); const safeAddListener = (element, event, handler, elementName) => { if (element) { element.addEventListener(event, handler.bind(this)); console.log(`  [LISTENER ADDED] 👍 ${elementName} - ${event}`); } else { console.warn(`  [LISTENER FAILED] ❓ Element not found for: ${elementName}`); } }; safeAddListener(this.elements.role, 'change', (e) => { console.log("[EVENT] Role changed"); this.renderStyles(e.target.value); this.renderTraits(e.target.value, ''); if(this.elements.style) this.elements.style.value = ''; this.updateLivePreview(); }, 'role'); safeAddListener(this.elements.style, 'change', (e) => { console.log("[EVENT] Style changed"); this.renderTraits(this.elements.role.value, e.target.value); this.updateLivePreview(); this.updateStyleExploreLink(); }, 'style'); safeAddListener(this.elements.name, 'input', () => { this.updateLivePreview(); }, 'name'); safeAddListener(this.elements.save, 'click', () => { console.log("[EVENT] Save clicked"); this.savePerson(); }, 'save'); safeAddListener(this.elements.clearForm, 'click', () => { console.log("[EVENT] Clear Form clicked"); this.resetForm(true); }, 'clearForm'); safeAddListener(this.elements.avatarPicker, 'click', (e) => { if (e.target.classList.contains('avatar-btn')) { console.log("[EVENT] Avatar clicked"); const emoji = e.target.dataset.emoji; this.elements.avatarInput.value = emoji; this.elements.avatarDisplay.textContent = emoji; this.elements.avatarPicker.querySelectorAll('.avatar-btn.selected').forEach(b=>b.classList.remove('selected')); e.target.classList.add('selected'); this.updateLivePreview();} }, 'avatarPicker'); safeAddListener(this.elements.traitsContainer, 'input', (e) => { if (e.target.classList.contains('trait-slider')) { this.handleTraitSliderInput(e); this.updateLivePreview(); } }, 'traitsContainer input'); safeAddListener(this.elements.traitsContainer, 'click', (e) => { if (e.target.classList.contains('trait-info-btn')) { console.log("[EVENT] Trait info clicked"); this.handleTraitInfoClick(e); } }, 'traitsContainer click'); safeAddListener(this.elements.formStyleFinderLink, 'click', () => { console.log("[EVENT] Form SF link clicked"); this.sfStart(); }, 'formStyleFinderLink'); safeAddListener(document.body, 'click', (e) => { if (e.target.classList.contains('context-help-btn')) { console.log("[EVENT] Context help clicked"); const key = e.target.dataset.helpKey; if(key) this.showContextHelp(key); } }, 'body context-help'); safeAddListener(this.elements.traitInfoClose, 'click', () => { console.log("[EVENT] Trait info close clicked"); this.hideTraitInfo(); }, 'traitInfoClose'); safeAddListener(this.elements.contextHelpClose, 'click', () => { console.log("[EVENT] Context help close clicked"); this.hideContextHelp(); }, 'contextHelpClose'); safeAddListener(this.elements.peopleList, 'click', this.handleListClick, 'peopleList click'); safeAddListener(this.elements.peopleList, 'keydown', this.handleListKeydown, 'peopleList keydown'); const modalsToClose = [ { modal: this.elements.modal, button: this.elements.modalClose, name: 'detailModal' }, { modal: this.elements.resourcesModal, button: this.elements.resourcesClose, name: 'resourcesModal' }, { modal: this.elements.glossaryModal, button: this.elements.glossaryClose, name: 'glossaryModal' }, { modal: this.elements.styleDiscoveryModal, button: this.elements.styleDiscoveryClose, name: 'styleDiscoveryModal' }, { modal: this.elements.themesModal, button: this.elements.themesClose, name: 'themesModal' }, { modal: this.elements.welcomeModal, button: this.elements.welcomeClose, name: 'welcomeModal' }, { modal: this.elements.achievementsModal, button: this.elements.achievementsClose, name: 'achievementsModal' }, { modal: this.elements.sfModal, button: this.elements.sfCloseBtn, name: 'sfModal' } ]; modalsToClose.forEach(item => { safeAddListener(item.button, 'click', () => { console.log(`[EVENT] Close clicked for ${item.name}`); this.closeModal(item.modal); }, `${item.name} Close`); }); safeAddListener(this.elements.resourcesBtn, 'click', () => { console.log("[EVENT] Resources clicked"); grantAchievement({}, 'resource_reader'); localStorage.setItem('kinkCompass_resource_reader', 'true'); this.openModal(this.elements.resourcesModal); }, 'resourcesBtn'); safeAddListener(this.elements.glossaryBtn, 'click', () => { console.log("[EVENT] Glossary clicked"); grantAchievement({}, 'glossary_user'); localStorage.setItem('kinkCompass_glossary_used', 'true'); this.showGlossary(); }, 'glossaryBtn'); safeAddListener(this.elements.styleDiscoveryBtn, 'click', () => { console.log("[EVENT] Style Discovery clicked"); grantAchievement({}, 'style_discovery'); localStorage.setItem('kinkCompass_style_discovery_viewed', 'true'); this.showStyleDiscovery(); }, 'styleDiscoveryBtn'); safeAddListener(this.elements.themesBtn, 'click', () => { console.log("[EVENT] Themes clicked"); this.openModal(this.elements.themesModal); }, 'themesBtn'); safeAddListener(this.elements.achievementsBtn, 'click', () => { console.log("[EVENT] Achievements clicked"); this.showAchievements(); }, 'achievementsBtn'); safeAddListener(this.elements.themeToggle, 'click', () => { console.log("[EVENT] Theme toggle clicked"); this.toggleTheme(); }, 'themeToggle'); safeAddListener(this.elements.exportBtn, 'click', () => { console.log("[EVENT] Export clicked"); this.exportData(); }, 'exportBtn'); safeAddListener(this.elements.importBtn, 'click', () => { console.log("[EVENT] Import clicked"); this.elements.importFileInput?.click(); }, 'importBtn'); safeAddListener(this.elements.importFileInput, 'change', (e) => { console.log("[EVENT] Import file selected"); this.importData(e); }, 'importFileInput'); safeAddListener(this.elements.styleFinderTriggerBtn, 'click', () => { console.log("[EVENT] Header SF trigger clicked"); this.sfStart(); }, 'styleFinderTriggerBtn'); safeAddListener(this.elements.styleDiscoveryRoleFilter, 'change', () => { console.log("[EVENT] Style Discovery filter changed"); this.renderStyleDiscoveryContent(); }, 'styleDiscoveryRoleFilter'); safeAddListener(this.elements.themesBody, 'click', this.handleThemeSelection, 'themesBody'); safeAddListener(this.elements.modalBody, 'click', this.handleModalBodyClick, 'modalBody'); safeAddListener(this.elements.modalTabs, 'click', this.handleDetailTabClick, 'modalTabs'); safeAddListener(this.elements.glossaryBody, 'click', this.handleGlossaryLinkClick, 'glossaryBody'); safeAddListener(document.body, 'click', this.handleGlossaryLinkClick, 'body glossaryLink'); safeAddListener(this.elements.styleExploreLink, 'click', this.handleExploreStyleLinkClick, 'styleExploreLink'); safeAddListener(this.elements.sfStepContent, 'click', (e) => { const button = e.target.closest('button'); if (button) { const action = button.dataset.action; if (action) { console.log(`[EVENT] SF button action: ${action}`); this.handleStyleFinderAction(action, button.dataset, e.target); } else if (button.classList.contains('sf-info-icon')) { console.log("[EVENT] SF trait info clicked"); const traitName = button.dataset.trait; if (traitName) this.sfShowTraitInfo(traitName, e.target); } } }, 'sfStepContent click'); safeAddListener(this.elements.sfStepContent, 'input', (e) => { if (e.target.classList.contains('sf-trait-slider')) { this.handleStyleFinderSliderInput(e.target); } }, 'sfStepContent input'); safeAddListener(window, 'keydown', this.handleWindowKeydown, 'window keydown'); safeAddListener(window, 'click', this.handleWindowClick, 'window click'); console.log("[ADD_LISTENERS] Setup COMPLETE."); }

  // --- Event Handlers --- (Keep Functions as they were, ensuring fixes are present)
  handleListClick(e) { console.log("[HANDLE_LIST_CLICK] START."); const target = e.target; const listItem = target.closest('li[data-id]'); if (!listItem) { console.log("[HANDLE_LIST_CLICK] Outside LI."); return; } const personIdStr = listItem.dataset.id; const personId = parseInt(personIdStr, 10); if (isNaN(personId)) { console.warn("[HANDLE_LIST_CLICK] Invalid ID:", personIdStr); return; } console.log(`[HANDLE_LIST_CLICK] ID: ${personId}`); if (target.closest('.edit-btn')) { console.log("[HANDLE_LIST_CLICK] Edit"); this.editPerson(personId); } else if (target.closest('.delete-btn')) { console.log("[HANDLE_LIST_CLICK] Delete"); const person = this.people.find(p => p.id === personId); const name = person?.name || 'persona'; if (confirm(`Delete ${this.escapeHTML(name)}?`)) { console.log("Delete confirmed."); this.deletePerson(personId); } else { console.log("Delete cancelled."); } } else if (target.closest('.person-info')) { console.log("[HANDLE_LIST_CLICK] Info -> showDetails"); this.showPersonDetails(personId); } else { console.log("[HANDLE_LIST_CLICK] Unhandled LI click."); } console.log("[HANDLE_LIST_CLICK] END"); }
  handleListKeydown(e) { if (e.key !== 'Enter' && e.key !== ' ') return; const target = e.target; const listItem = target.closest('li[data-id]'); if (!listItem) return; const personIdStr = listItem.dataset.id; const personId = parseInt(personIdStr, 10); if (isNaN(personId)) { console.warn("[HANDLE_LIST_KEYDOWN] Invalid ID:", personIdStr); return; } if (target.closest('.person-actions') && (target.classList.contains('edit-btn') || target.classList.contains('delete-btn'))) { console.log("[HANDLE_LIST_KEYDOWN] Activating button."); e.preventDefault(); target.click(); } else if (e.key === 'Enter' && (target === listItem || target.closest('.person-info'))) { console.log("[HANDLE_LIST_KEYDOWN] Activating details."); e.preventDefault(); this.showPersonDetails(personId); } }
  handleWindowClick(e) { if (this.elements.traitInfoPopup?.getAttribute('aria-hidden') === 'false') { const pc = this.elements.traitInfoPopup; const tb = document.querySelector('.trait-info-btn[aria-expanded="true"]'); if (pc && !pc.contains(e.target) && e.target !== tb && !tb?.contains(e.target)) { console.log("[WINDOW_CLICK] Closing trait info."); this.hideTraitInfo(); } } if (this.elements.contextHelpPopup?.getAttribute('aria-hidden') === 'false') { const pc = this.elements.contextHelpPopup; const tb = document.querySelector('.context-help-btn[aria-expanded="true"]'); if (pc && !pc.contains(e.target) && e.target !== tb && !tb?.contains(e.target)) { console.log("[WINDOW_CLICK] Closing context help."); this.hideContextHelp(); } } const sf = document.querySelector('.sf-style-info-popup'); if (sf) { const tb = document.querySelector('.sf-info-icon.active, button[data-action="showDetails"].active'); if (!sf.contains(e.target) && e.target !== tb && !tb?.contains(e.target)) { console.log("[WINDOW_CLICK] Removing SF popup."); sf.remove(); tb?.classList.remove('active'); } } }
  handleWindowKeydown(e) { if (e.key === 'Escape') { console.log("[WINDOW_KEYDOWN] Escape."); if (this.elements.traitInfoPopup?.getAttribute('aria-hidden') === 'false') { console.log(" -> Close trait info."); this.hideTraitInfo(); return; } if (this.elements.contextHelpPopup?.getAttribute('aria-hidden') === 'false') { console.log(" -> Close context help."); this.hideContextHelp(); return; } const sf = document.querySelector('.sf-style-info-popup'); if (sf) { console.log(" -> Remove SF popup."); sf.remove(); document.querySelector('.sf-info-icon.active, button[data-action="showDetails"].active')?.classList.remove('active'); return; } const om = document.querySelector('.modal[aria-hidden="false"]'); if (om) { console.log(` -> Close modal #${om.id}.`); this.closeModal(om); } else { console.log(" -> No active modal/popup."); } } }
  handleTraitSliderInput(e) { const s = e.target; const t = s.closest('.trait'); const v = t?.querySelector('.trait-value'); if (v) v.textContent = s.value; else console.warn("[TRAIT_SLIDER] Value display missing:", s); this.updateTraitDescription(s); }
  handleTraitInfoClick(e) { const b = e.target.closest('.trait-info-btn'); if (!b) { console.warn("[TRAIT_INFO_CLICK] Not on button."); return; } const tN = b.dataset.trait; if (!tN) { console.warn("[TRAIT_INFO_CLICK] Missing data-trait."); return; } console.log(`[TRAIT_INFO_CLICK] Show: ${tN}`); this.showTraitInfo(tN); document.querySelectorAll('.trait-info-btn[aria-expanded="true"]').forEach(btn => { if (btn !== b) btn.setAttribute('aria-expanded', 'false'); }); b.setAttribute('aria-expanded', b.getAttribute('aria-expanded') === 'true' ? 'false' : 'true'); }
  handleModalBodyClick(e) { const dM = this.elements.modal; const pIS = dM?.dataset.personId; if (!pIS) return; const pI = parseInt(pIS, 10); if (isNaN(pI)) { console.warn("[MODAL_BODY_CLICK] Invalid personId:", pIS); return; } const t = e.target; const b = t.closest('button'); if (b) { if (b.classList.contains('toggle-goal-btn')) { const gIS = b.dataset.goalId; const gI = parseInt(gIS, 10); if (!isNaN(gI)) { console.log(`[MODAL_BODY_CLICK] Toggle goal ${gI}`); this.toggleGoalStatus(pI, gI, b.closest('li')); } else { console.warn("[MODAL_BODY_CLICK] Invalid goalId:", gIS); } return; } if (b.classList.contains('delete-goal-btn')) { const gIS = b.dataset.goalId; const gI = parseInt(gIS, 10); if (!isNaN(gI)) { if (confirm("Delete goal?")) { console.log(`[MODAL_BODY_CLICK] Delete goal ${gI}`); this.deleteGoal(pI, gI); } else { console.log("Delete cancelled."); } } else { console.warn("[MODAL_BODY_CLICK] Invalid goalId:", gIS); } return; } if (b.id === 'add-goal-btn') { const f = b.closest('form#add-goal-form'); if (f) { e.preventDefault(); console.log(`[MODAL_BODY_CLICK] Add goal btn.`); this.addGoal(pI, f); } else { console.warn("Add goal btn, no form."); } return; } switch (b.id) { case 'snapshot-btn': console.log(`[MODAL_BODY_CLICK] Snapshot`); this.addSnapshotToHistory(pI); return; case 'journal-prompt-btn': console.log(`[MODAL_BODY_CLICK] Prompt`); this.showJournalPrompt(pI); return; case 'save-reflections-btn': console.log(`[MODAL_BODY_CLICK] Save reflections`); this.saveReflections(pI); return; case 'oracle-btn': console.log(`[MODAL_BODY_CLICK] Oracle`); this.showKinkOracle(pI); return; } if (b.classList.contains('glossary-link')) { const tK = b.dataset.termKey; if (tK) { console.log(`[MODAL_BODY_CLICK] Glossary link: ${tK}`); e.preventDefault(); this.closeModal(dM); this.showGlossary(tK); } else { console.warn("Glossary link, no key."); } return; } } if (t.closest('form#add-goal-form') && (e.type === 'submit' || (e.type === 'keydown' && e.key === 'Enter'))) { const f = t.closest('form#add-goal-form'); if (f) { e.preventDefault(); if(document.activeElement === f.querySelector('input[type="text"]') || e.type === 'submit') { console.log(`[MODAL_BODY_CLICK/SUBMIT] Add goal form.`); this.addGoal(pI, f); } else { console.log("Enter in form, not input."); } return; } } }
  handleThemeSelection(e) { console.log("[THEME_SELECT] Click."); const b = e.target.closest('.theme-option-btn'); if (b?.dataset.theme) { const tN = b.dataset.theme; console.log(`[THEME_SELECT] Theme: ${tN}`); this.setTheme(tN); this.closeModal(this.elements.themesModal); } else { console.log("[THEME_SELECT] Not button."); } }
  handleStyleFinderAction(action, dataset = {}, triggerElement = null) { console.log(`[SF_ACTION] Action: ${action}`, dataset); switch (action) { case 'start': this.sfNextStep(); break; case 'setRole': if (dataset.role) this.sfSetRole(dataset.role); else console.warn("[SF_ACTION] setRole missing."); break; case 'next': this.sfNextStep(dataset.currenttrait || null); break; case 'prev': this.sfPrevStep(); break; case 'startOver': this.sfStartOver(); break; case 'showDetails': if (dataset.style) this.sfShowFullDetails(dataset.style, triggerElement); else console.warn("[SF_ACTION] showDetails missing."); break; case 'confirmApply': if(dataset.role && dataset.style) this.confirmApplyStyleFinderResult(dataset.role, dataset.style); else console.warn("[SF_ACTION] confirmApply missing."); break; default: console.warn(`[SF_ACTION] Unknown: ${action}`); } }
  handleStyleFinderSliderInput(sliderElement) { this.sfSliderInteracted = true; /* console.log("[SF_SLIDER] Interaction flag set."); */ const tN = sliderElement.dataset.trait; const v = sliderElement.value; const dE = document.getElementById(`sf-desc-${tN}`); if (!tN) { console.warn("[SF_SLIDER] Missing data-trait."); return; } this.sfSetTrait(tN, v); const rD = this.sliderDescriptions; if (dE && rD && rD[tN]) { const dA = rD[tN]; const i = parseInt(v, 10) - 1; if (i >= 0 && i < dA.length) dE.textContent = dA[i]; else console.warn(`[SF_SLIDER] Invalid index ${i} for ${tN}`); } this.sfUpdateDashboard(); }
  handleDetailTabClick(e) { const target = e.target.closest('.tab-link'); if (!target) return; e.preventDefault(); const tabId = target.dataset.tabId; console.log(`[DETAIL_TAB_CLICK] Tab: ${tabId}`); if (!tabId || tabId === this.activeDetailModalTab) { return; } const personIdStr = this.elements.modal?.dataset.personId; const personId = parseInt(personIdStr, 10); if (isNaN(personId)) { console.warn("[DETAIL_TAB_CLICK] Invalid personId."); return; } const person = this.people.find(p => p.id === personId); if (!person) { console.error(`[DETAIL_TAB_CLICK] Person ${personId} not found.`); return; } this.elements.modalTabs.querySelectorAll('.tab-link').forEach(t => { t.classList.remove('active'); t.setAttribute('aria-selected', 'false'); }); this.elements.modalBody.querySelectorAll('.tab-content').forEach(p => p.classList.remove('active')); target.classList.add('active'); target.setAttribute('aria-selected', 'true'); const activePane = this.elements.modalBody.querySelector(`.tab-content[data-tab-id="${tabId}"]`); if (activePane) { activePane.classList.add('active'); this.activeDetailModalTab = tabId; console.log(`[DETAIL_TAB_CLICK] Activated: ${tabId}`); const needsRender = !activePane.innerHTML.trim() || tabId === 'tab-history'; if (needsRender) { console.log(`[DETAIL_TAB_CLICK] Rendering: ${tabId}`); this.renderDetailTabContent(person, tabId, activePane); if (tabId === 'tab-history' && person.history?.length >= 2) { setTimeout(() => { console.log("[DETAIL_TAB_CLICK] Delayed chart render."); this.renderHistoryChart(person, 'history-chart'); }, 150); } } else { console.log(`[DETAIL_TAB_CLICK] Content exists.`); } } else { console.warn(`[DETAIL_TAB_CLICK] Pane not found: ${tabId}`); } }
  handleGlossaryLinkClick(e) { const link = e.target.closest('.glossary-link'); if (link) { const termKey = link.dataset.termKey; if (termKey) { console.log(`[GLOSSARY_LINK_CLICK] Term: ${termKey}`); e.preventDefault(); const openModal = document.querySelector('.modal[aria-hidden="false"]:not(#glossary-modal)'); if(openModal) { console.log(`[GLOSSARY_LINK_CLICK] Closing other modal: #${openModal.id}`); this.closeModal(openModal); } this.showGlossary(termKey); } else { console.warn("[GLOSSARY_LINK_CLICK] No term key."); } } }
  handleExploreStyleLinkClick(e) { e.preventDefault(); const styleName = e.target.dataset.styleName; if (styleName) { console.log(`[EXPLORE_STYLE_LINK] Style: ${styleName}`); this.showStyleDiscovery(styleName); } else { console.warn("[EXPLORE_STYLE_LINK] No style name."); } }

  // --- Core Rendering --- (Keep Functions as they were)
  renderStyles(roleKey) { console.log(`[RENDERSTYLES] START - Role: ${roleKey}`); const styleSelect = this.elements.style; if (!styleSelect) { console.error("[RENDERSTYLES] CRITICAL - Select element missing!"); return; } if (!roleKey) { console.warn("[RENDERSTYLES] No role key."); styleSelect.innerHTML = '<option value="">-- Select Role First --</option>'; console.log("[RENDERSTYLES] END - No role."); return; } console.log(`[RENDERSTYLES] Accessing data for ${roleKey}`); const stylesData = bdsmData[roleKey]?.styles; console.log(`[RENDERSTYLES] Data:`, stylesData); if (!stylesData || !Array.isArray(stylesData)) { console.warn(`[RENDERSTYLES] No styles for ${roleKey}.`); styleSelect.innerHTML = '<option value="">-- No Styles Available --</option>'; console.log("[RENDERSTYLES] END - No styles data."); return; } console.log(`[RENDERSTYLES] Found ${stylesData.length} styles. Clearing.`); styleSelect.innerHTML = '<option value="">-- Select a Style --</option>'; console.log("[RENDERSTYLES] Adding options..."); stylesData.forEach((style, index) => { if (!style?.name) { console.warn(`[RENDERSTYLES] Invalid style at index ${index}:`, style); return; } const option = document.createElement('option'); option.value = style.name; option.textContent = style.name; styleSelect.appendChild(option); }); console.log("[RENDERSTYLES] Added options."); styleSelect.offsetHeight; console.log("[RENDERSTYLES] Forced reflow."); console.log("[RENDERSTYLES] END"); }
  renderTraits(roleKey, styleName) { console.log(`[RENDERTRAITS] START - Role: ${roleKey}, Style: ${styleName}`); const container = this.elements.traitsContainer, messageEl = this.elements.traitsMessage; if (!container || !messageEl) { console.error("[RENDERTRAITS] CRITICAL - Elements missing!"); return; } container.innerHTML = ''; messageEl.style.display = 'none'; if (!roleKey) { console.log("[RENDERTRAITS] No role."); messageEl.textContent = 'Select Role for traits.'; messageEl.style.display = 'block'; container.style.display = 'none'; console.log("[RENDERTRAITS] END - No role."); return; } console.log(`[RENDERTRAITS] Accessing data for ${roleKey}`); const roleData = bdsmData[roleKey]; if (!roleData) { console.warn(`[RENDERTRAITS] No data for ${roleKey}`); messageEl.textContent = `Error: Data missing for '${roleKey}'.`; messageEl.style.display = 'block'; container.style.display = 'none'; console.log("[RENDERTRAITS] END - Role data missing."); return; } let traitsToRender = []; if (roleData.coreTraits?.length) traitsToRender.push(...roleData.coreTraits); else console.warn(`[RENDERTRAITS] No core traits for ${roleKey}.`); let selectedStyleObj = null; if (styleName && roleData.styles?.length) { selectedStyleObj = roleData.styles.find(s => s.name === styleName); if (selectedStyleObj?.traits?.length) traitsToRender.push(...selectedStyleObj.traits); else if (selectedStyleObj) console.log(`[RENDERTRAITS] No specific traits for ${styleName}.`); else console.warn(`[RENDERTRAITS] Style object not found: ${styleName}`); } else if (styleName) console.warn(`[RENDERTRAITS] Style name '${styleName}', but no styles array.`); const uniqueTraitNames = new Set(); const finalTraits = traitsToRender.filter(trait => { if (!trait?.name) return false; if (!uniqueTraitNames.has(trait.name)) { uniqueTraitNames.add(trait.name); return true; } return false; }); console.log(`[RENDERTRAITS] Unique traits: ${finalTraits.length}`); if (finalTraits.length === 0) { if (styleName) messageEl.textContent = `No traits defined for '${styleName}'.`; else if (roleKey) messageEl.textContent = `No core traits for '${roleKey}'.`; else messageEl.textContent = 'Select Role & Style...'; messageEl.style.display = 'block'; container.style.display = 'none'; console.log("[RENDERTRAITS] END - No traits."); return; } let currentValues = {}; if (this.currentEditId !== null) { const person = this.people.find(p => p.id === this.currentEditId); currentValues = person?.traits || {}; } console.log("[RENDERTRAITS] Creating trait HTML..."); finalTraits.forEach((trait) => { const currentValue = currentValues[trait.name] ?? 3; const traitHTML = this.createTraitHTML(trait, currentValue); container.insertAdjacentHTML('beforeend', traitHTML); const slider = container.querySelector(`input[name="${trait.name}"]`); if(slider) this.updateTraitDescription(slider); else console.warn(`[RENDERTRAITS] Slider missing after insert: ${trait.name}`); }); console.log("[RENDERTRAITS] Finished trait HTML."); container.style.display = 'block'; console.log("[RENDERTRAITS] END"); }
  createTraitHTML(trait, value = 3) { if (!trait?.name || !trait.desc) { console.error("[CREATE_TRAIT_HTML] Invalid trait:", trait); return '<p>Error.</p>'; } const validValue = Math.max(1, Math.min(5, parseInt(value, 10) || 3)); const safeName = this.escapeHTML(trait.name); return ` <div class="trait" data-trait-name="${safeName}"><label class="trait-label" for="trait-${safeName}">${safeName}<button type="button" class="trait-info-btn small-btn context-help-btn" data-trait="${safeName}" aria-label="Info about ${safeName}" aria-expanded="false">?</button></label><input type="range" id="trait-${safeName}" name="${safeName}" class="trait-slider" min="1" max="5" value="${validValue}" aria-describedby="desc-${safeName}"><span class="trait-value" aria-live="polite">${validValue}</span><div id="desc-${safeName}" class="trait-desc muted-text" aria-live="polite">${this.escapeHTML(trait.desc[validValue] || 'Loading...')}</div></div> `; }
  updateTraitDescription(slider) { if (!slider) { console.warn("[UPDATE_TRAIT_DESC] Null slider."); return; } const traitName = slider.name; const value = slider.value; const descElement = document.getElementById(`desc-${traitName}`); if (!descElement) return; let traitDefinition = null; const currentRole = this.elements.role.value; const currentStyle = this.elements.style.value; if(currentRole && bdsmData[currentRole]) { traitDefinition = bdsmData[currentRole].coreTraits?.find(t => t.name === traitName) || bdsmData[currentRole].styles?.find(s => s.name === currentStyle)?.traits?.find(t => t.name === traitName); } if (!traitDefinition) { for (const roleKey in bdsmData) { traitDefinition = bdsmData[roleKey].coreTraits?.find(t => t.name === traitName) || bdsmData[roleKey].styles?.flatMap(s => s.traits || []).find(t => t.name === traitName); if(traitDefinition) break; } } if (traitDefinition?.desc?.[value]) { descElement.textContent = this.escapeHTML(traitDefinition.desc[value]); } else { descElement.textContent = '...'; console.warn(`[UPDATE_TRAIT_DESC] Desc missing for '${traitName}' value ${value}.`); } }
  renderList() { console.log("[RENDERLIST] START."); const listElement = this.elements.peopleList; if (!listElement) { console.error("[RENDERLIST] CRITICAL - List element missing!"); return; } console.log(`[RENDERLIST] Count: ${this.people.length}`); listElement.innerHTML = ''; if (this.people.length === 0) { listElement.innerHTML = '<li>No personas yet.</li>'; console.log("[RENDERLIST] Empty."); } else { console.log("[RENDERLIST] Creating items..."); this.people.forEach((person) => listElement.insertAdjacentHTML('beforeend', this.createPersonListItemHTML(person))); if (this.lastSavedId !== null) { const item = listElement.querySelector(`li[data-id="${this.lastSavedId}"]`); if (item) { console.log(`[RENDERLIST] Highlighting ID: ${this.lastSavedId}`); item.classList.add('item-just-saved'); setTimeout(() => item.classList.remove('item-just-saved'), 1500); } this.lastSavedId = null; } console.log("[RENDERLIST] Finished items."); } console.log("[RENDERLIST] END"); }
  createPersonListItemHTML(person) { if (!person?.id) { console.error("[CREATE_PERSON_HTML] Invalid person:", person); return '<li>Error.</li>'; } const ac = person.achievements?.length || 0; const ap = ac > 0 ? `<span class="person-achievements-preview">🏆 ${ac}</span>` : ''; const tn = person.name.length > 30 ? this.escapeHTML(person.name.substring(0, 27)) + "..." : this.escapeHTML(person.name); return ` <li data-id="${person.id}" tabindex="-1"><div class="person-info" tabindex="0" role="button" aria-label="View ${this.escapeHTML(person.name)}"><span class="person-avatar">${this.escapeHTML(person.avatar || '❓')}</span><div class="person-name-details"><span class="person-name">${tn}</span><span class="person-details muted-text">${this.escapeHTML(person.role || '')} / ${this.escapeHTML(person.style || 'N/A')} ${ap}</span></div></div><div class="person-actions"><button class="small-btn edit-btn" aria-label="Edit ${this.escapeHTML(person.name)}">Edit</button><button class="small-btn delete-btn" aria-label="Delete ${this.escapeHTML(person.name)}">Delete</button></div></li> `; }
  updateStyleExploreLink() { const s = this.elements.style, l = this.elements.styleExploreLink; if (!l || !s) return; const sn = s.value; if (sn) { /*console.log(`[UPDATE_STYLE_LINK] Update for: ${sn}`);*/ l.dataset.styleName = sn; l.style.display = 'inline'; l.setAttribute('aria-label', `Explore ${this.escapeHTML(sn)}`); } else { /*console.log("[UPDATE_STYLE_LINK] Hide.");*/ l.style.display = 'none'; l.removeAttribute('data-style-name'); l.setAttribute('aria-label', `Explore details`); } }

  // --- CRUD --- (Keep Functions as they were, ensuring resetForm uses the manual fix)
  savePerson() { console.log("[SAVE_PERSON] START"); const name = this.elements.name.value.trim(); const role = this.elements.role.value; const style = this.elements.style.value; const avatar = this.elements.avatarInput.value || '❓'; console.log(`[SAVE_PERSON] Data - Name: ${name}, Role: ${role}, Style: ${style}, Avatar: ${avatar}, Edit ID: ${this.currentEditId}`); if (!name) { this.showNotification("Enter name.", "error"); console.warn("[SAVE_PERSON] Fail: Name missing."); this.elements.name.focus(); return; } if (!style && bdsmData[role]?.styles?.length > 0) { this.showNotification("Select style.", "error"); console.warn("[SAVE_PERSON] Fail: Style missing."); this.elements.style.focus(); return; } const traits = {}; this.elements.traitsContainer.querySelectorAll('.trait-slider').forEach(slider => { traits[slider.name] = parseInt(slider.value, 10); }); console.log("[SAVE_PERSON] Traits:", traits); let personData; let isNewPerson = false; if (this.currentEditId !== null) { console.log(`[SAVE_PERSON] Editing ID: ${this.currentEditId}`); const personIndex = this.people.findIndex(p => p.id === this.currentEditId); if (personIndex === -1) { console.error(`[SAVE_PERSON] Edit Fail: ID ${this.currentEditId} not found!`); this.showNotification("Error updating.", "error"); this.resetForm(); return; } personData = this.people[personIndex]; personData.name = name; personData.role = role; personData.style = style; personData.avatar = avatar; personData.traits = traits; personData.lastUpdated = new Date().toISOString(); grantAchievement(personData, 'profile_edited'); console.log(`[SAVE_PERSON] Updated.`); } else { console.log("[SAVE_PERSON] Creating new."); isNewPerson = true; const newId = Date.now(); personData = { id: newId, name, role, style, avatar, traits, goals: [], history: [], reflections: "", achievements: [], createdAt: new Date().toISOString(), lastUpdated: new Date().toISOString(), }; grantAchievement(personData, 'profile_created'); if (avatar !== '❓') grantAchievement(personData, 'avatar_chosen'); this.people.push(personData); console.log(`[SAVE_PERSON] Created ID ${newId}.`); } Object.values(traits).forEach(score => { if(score === 5) grantAchievement(personData, 'max_trait'); if(score === 1) grantAchievement(personData, 'min_trait'); }); if(isNewPerson && this.people.length >= 5) { grantAchievement({}, 'five_profiles'); localStorage.setItem('kinkCompass_five_profiles', 'true'); } this.lastSavedId = personData.id; this.saveToLocalStorage(); this.showNotification(`'${this.escapeHTML(name)}' saved!`, 'success'); this.renderList(); this.resetForm(); console.log("[SAVE_PERSON] END - Success."); }
  editPerson(personId) { console.log(`[EDIT_PERSON] START - ID: ${personId}`); const person = this.people.find(p => p.id === personId); if (!person) { console.error(`[EDIT_PERSON] Fail: ID ${personId} not found.`); this.showNotification(`Error: Not found.`, "error"); return; } console.log("[EDIT_PERSON] Found:", person); this.elements.name.value = person.name; this.elements.role.value = person.role; this.elements.avatarInput.value = person.avatar || '❓'; this.elements.avatarDisplay.textContent = person.avatar || '❓'; this.elements.avatarPicker.querySelectorAll('.avatar-btn.selected').forEach(b=>b.classList.remove('selected')); const avatarBtn = this.elements.avatarPicker.querySelector(`.avatar-btn[data-emoji="${person.avatar}"]`); if(avatarBtn) avatarBtn.classList.add('selected'); console.log("[EDIT_PERSON] Rendering styles for:", person.role); this.renderStyles(person.role); this.elements.style.value = person.style; console.log("[EDIT_PERSON] Set style value:", person.style); console.log("[EDIT_PERSON] Rendering traits for:", person.role, person.style); this.currentEditId = personId; this.renderTraits(person.role, person.style); if (this.elements.formTitle) this.elements.formTitle.textContent = `✨ Editing: ${this.escapeHTML(person.name)} ✨`; this.elements.save.textContent = 'Update Persona!💾'; this.elements.clearForm.textContent = 'Cancel Edit ❌'; this.updateLivePreview(); this.updateStyleExploreLink(); this.elements.formSection.scrollIntoView({ behavior: 'smooth' }); this.elements.name.focus(); console.log("[EDIT_PERSON] END - Populated."); }
  deletePerson(personId) { console.log(`[DELETE_PERSON] START - ID: ${personId}`); const initialLength = this.people.length; this.people = this.people.filter(p => p.id !== personId); if (this.people.length < initialLength) { this.saveToLocalStorage(); this.renderList(); this.showNotification("Deleted.", "info"); console.log(`[DELETE_PERSON] END - Success.`); if (this.currentEditId === personId) { console.log("[DELETE_PERSON] Resetting form."); this.resetForm(); } } else { console.error(`[DELETE_PERSON] END - Fail: ID ${personId} not found.`); this.showNotification("Error deleting.", "error"); } }
  resetForm(isManualClear = false) { console.log(`[RESET_FORM] START - Manual: ${isManualClear}, Edit ID: ${this.currentEditId}`); if (!isManualClear && this.currentEditId !== null) console.log("[RESET_FORM] Canceling edit."); else if (isManualClear) console.log("[RESET_FORM] Manual clear."); this.elements.name.value = ''; this.elements.role.value = 'submissive'; this.elements.avatarInput.value = '❓'; this.elements.avatarDisplay.textContent = '❓'; this.elements.avatarPicker.querySelectorAll('.avatar-btn.selected').forEach(b => b.classList.remove('selected')); if (this.elements.traitsContainer) { this.elements.traitsContainer.innerHTML = ''; if(this.elements.traitsMessage) { this.elements.traitsMessage.textContent = 'Select Role & Style...'; this.elements.traitsMessage.style.display = 'block'; } this.elements.traitsContainer.style.display = 'none'; } console.log("[RESET_FORM] Manually reset done."); this.renderStyles(this.elements.role.value); this.elements.style.value = ''; this.currentEditId = null; if (this.elements.formTitle) this.elements.formTitle.textContent = '✨ Create New Persona ✨'; this.elements.save.textContent = 'Save Persona! 💖'; this.elements.clearForm.textContent = 'Clear Form 🧹'; this.updateLivePreview(); this.updateStyleExploreLink(); console.log("[RESET_FORM] END - Complete."); }

  // --- Live Preview --- (With Synergy Hint)
  updateLivePreview() {
       console.log("[LIVE_PREVIEW] Updating...");
       const previewElement = this.elements.livePreview;
       if (!previewElement) { console.error("[LIVE_PREVIEW] Element not found!"); return; }

       const name = this.elements.name.value.trim() || "[Persona Name]";
       const role = this.elements.role.value;
       const style = this.elements.style.value;
       const avatar = this.elements.avatarInput.value || '❓';

       const traits = {};
       this.elements.traitsContainer.querySelectorAll('.trait-slider').forEach(slider => { traits[slider.name] = parseInt(slider.value, 10); });

       let previewHTML = `
             <h3 class="preview-title">${this.escapeHTML(avatar)} ${this.escapeHTML(name)}</h3>
             <p style="text-align:center;">(${this.escapeHTML(role)} / ${style ? this.escapeHTML(style) : '[Select Style]'})</p>
         `;

       if (role && style && Object.keys(traits).length > 0) {
             let breakdown; try { if (role === 'submissive') breakdown = getSubBreakdown(style, traits); else if (role === 'dominant') breakdown = getDomBreakdown(style, traits); else breakdown = { strengths: "Traits define flexibility!", improvements: "Consider current leaning." }; if (breakdown?.strengths && breakdown?.improvements) { previewHTML += `<div class="preview-breakdown"><h4>Vibe Check:</h4><p class="strengths">${breakdown.strengths}</p><h4>Growth Edge:</h4><p class="improvements">${breakdown.improvements}</p></div>`; } else { previewHTML += `<p class="muted-text">Cannot generate breakdown.</p>`; } } catch (error) { console.error(`[LIVE_PREVIEW] Breakdown Error:`, error); previewHTML += `<p class="error-text">Breakdown Error.</p>`; }
       } else if (role && Object.keys(traits).length > 0 && !style) { previewHTML += `<p class="muted-text">Select Style for breakdown...</p>`;
       } else { previewHTML += `<p class="muted-text">Fill form for preview...</p>`; }

       // <<< ADD SYNERGY HINT >>>
       if (Object.keys(traits).length > 1) { // Need at least two traits for synergy
           const hints = this.getSynergyHints({ traits }); // Pass temporary object
           if (hints.length > 0) {
                const randomHint = hints[Math.floor(Math.random() * hints.length)];
                previewHTML += `<div class="preview-synergy-hint"><strong>Synergy Hint:</strong> ${this.escapeHTML(randomHint.text)}</div>`;
                console.log("[LIVE_PREVIEW] Added Synergy Hint.");
           }
       }

       // <<< ADD Daily Challenge Placeholder >>>
       previewHTML += `<div id="daily-challenge-area" style="margin-top: 1.5em; padding-top: 1em; border-top: 1px dashed var(--border-color);"><p class="muted-text">Loading focus...</p></div>`;

       previewElement.innerHTML = previewHTML;
       this.displayDailyChallenge(); // Display challenge in its area
       console.log("[LIVE_PREVIEW] Update complete.");
   } // End updateLivePreview

  // --- Modal Display ---
  showPersonDetails(personId) {
      console.log(`[SHOW_PERSON_DETAILS] START - ID: ${personId}`);
      const person = this.people.find(p => p.id === personId);
      if (!person) { console.error(`[SHOW_PERSON_DETAILS] Fail: ID ${personId} not found.`); this.showNotification("Cannot load details.", "error"); return; }
      console.log(`[SHOW_PERSON_DETAILS] Found: ${person.name}`);
      const detailModal=this.elements.modal, modalBody=this.elements.modalBody, modalTabsContainer=this.elements.modalTabs, modalTitle=this.elements.detailModalTitle;
      if (!detailModal || !modalBody || !modalTabsContainer || !modalTitle) { console.error("[SHOW_PERSON_DETAILS] Fail: Modal elements missing."); this.showNotification("UI Error.", "error"); return; }
      console.log("[SHOW_PERSON_DETAILS] Modal elements found.");

      detailModal.dataset.personId = personId;
      modalTitle.textContent = `${person.avatar || '❓'} ${this.escapeHTML(person.name)} - Details`;
      modalBody.innerHTML = ''; modalTabsContainer.innerHTML = '';

      // <<< MERGED TABS DEFINITION >>>
      const tabs = [
          { id: 'tab-traits-breakdown', label: 'Traits & Breakdown', icon: '📊' },
          { id: 'tab-goals-journal', label: 'Goals & Journal', icon: '📝' },
          { id: 'tab-history', label: 'History', icon: '📈' },
          { id: 'tab-insights', label: 'Insights', icon: '💡' },
      ];
      this.activeDetailModalTab = 'tab-traits-breakdown'; // Reset default tab

      console.log(`[SHOW_PERSON_DETAILS] Rendering ${tabs.length} merged tabs/panes...`);
      tabs.forEach((tab) => {
            const tabButton = document.createElement('button'); tabButton.className = 'tab-link'; tabButton.textContent = `${tab.icon} ${tab.label}`; tabButton.dataset.tabId = tab.id; tabButton.setAttribute('role', 'tab'); tabButton.setAttribute('aria-controls', `${tab.id}-content`); tabButton.id = `${tab.id}-tab`; const isActive = tab.id === this.activeDetailModalTab; tabButton.classList.toggle('active', isActive); tabButton.setAttribute('aria-selected', isActive ? 'true' : 'false'); modalTabsContainer.appendChild(tabButton);
            const contentPane = document.createElement('div'); contentPane.className = 'tab-content'; contentPane.dataset.tabId = tab.id; contentPane.id = `${tab.id}-content`; contentPane.setAttribute('role', 'tabpanel'); contentPane.setAttribute('aria-labelledby', `${tab.id}-tab`); contentPane.classList.toggle('active', isActive); contentPane.innerHTML = ''; modalBody.appendChild(contentPane);
            if (isActive) { console.log(`[SHOW_PERSON_DETAILS] Rendering initial tab: ${tab.id}`); this.renderDetailTabContent(person, tab.id, contentPane); if (tab.id === 'tab-history' && person.history?.length >= 2) { setTimeout(() => { console.log("[SHOW_PERSON_DETAILS] Initial chart render."); this.renderHistoryChart(person, 'history-chart'); }, 150); } }
      });

      console.log("[SHOW_PERSON_DETAILS] Calling openModal...");
      this.openModal(detailModal);
      console.log("[SHOW_PERSON_DETAILS] END - Modal open.");
  } // End showPersonDetails

  // Updated to handle merged tabs
  renderDetailTabContent(person, tabId, contentElement) {
        console.log(`[RENDER_DETAIL_TAB] Person ${person.id}, Tab ${tabId}`);
        if (!contentElement) { console.error(`[RENDER_DETAIL_TAB] Fail: No element for ${tabId}.`); return; }
        contentElement.innerHTML = ''; // Clear

        try {
            let htmlContent = '';
            switch (tabId) {
                case 'tab-goals-journal': htmlContent = this.renderGoalsJournalTab(person); break;
                case 'tab-traits-breakdown': htmlContent = this.renderTraitsBreakdownTab(person); break;
                case 'tab-history': htmlContent = this.renderHistoryTab(person); break; // Chart rendered by handler
                case 'tab-insights': htmlContent = this.renderInsightsTab(person); break;
                default: console.warn(`[RENDER_DETAIL_TAB] Unknown tabId: ${tabId}`); htmlContent = `<p>No content.</p>`;
            }
             contentElement.innerHTML = htmlContent;
             console.log(`[RENDER_DETAIL_TAB] Success for ${tabId}`);
        } catch (error) {
            console.error(`[RENDER_DETAIL_TAB] Error rendering ${tabId}:`, error);
            contentElement.innerHTML = `<p class="error-text">Error loading.</p>`;
        }
    } // End renderDetailTabContent

  // --- New Rendering Functions for Merged Tabs --- (Keep Functions as they were)
  renderTraitsBreakdownTab(person) { console.log("[RENDER_MERGED] Traits & Breakdown"); return `${this.renderTraitDetails(person)} ${this.renderStyleBreakdownDetail(person)}`; }
  renderGoalsJournalTab(person) { console.log("[RENDER_MERGED] Goals & Journal"); return `${this.renderGoalList(person)} ${this.renderJournalTab(person)}`; }
  renderInsightsTab(person) { console.log("[RENDER_MERGED] Insights"); let content = this.renderAchievementsList(person); content += `<section class="oracle-tab-content"><h3>🔮 Kink Compass Oracle</h3><div id="oracle-reading-output" class="kink-reading-output"><p>Consult Oracle...</p></div><div class="modal-actions"><button type="button" id="oracle-btn" class="small-btn accent-btn">Consult Oracle ✨</button></div></section>`; const challenge = this.getDailyChallenge(person); content += `<section><h3>🌟 Today's Focus 🌟</h3>`; if (challenge) { content += `<h5>${this.escapeHTML(challenge.title)}</h5><p>${this.escapeHTML(challenge.desc)}</p><p class="muted-text"><small>(Category: ${this.escapeHTML(challenge.category)})</small></p>`; } else { content += `<p class="muted-text">No focus challenge.</p>`; } content += `</section>`; return content; }

  // --- Individual Component Rendering Functions --- (Keep Functions as they were)
  renderTraitDetails(person) { console.log(`[RENDER_TRAIT_DETAILS] P ${person.id}`); let c='<section><h3>🎨 Traits Profile</h3>'; const rd=bdsmData[person.role]; if(!rd) return '<p>Role data err.</p>'; const at=[...(rd.coreTraits||[]), ...(rd.styles?.find(s=>s.name===person.style)?.traits||[])]; const ut=[...new Map(at.map(i=>[i?.name,i])).values()].filter(Boolean); if(ut.length===0){c+='<p>No traits.</p>';} else {c+='<div class="trait-details-grid">'; ut.forEach(t=>{const s=person.traits?.[t.name]; const vs=(!isNaN(parseInt(s))&&s>=1&&s<=5)?s:3; const d=t.desc?.[vs]||t.explanation||'N/A.'; const f=this.getFlairForScore(vs); c+=`<div class="trait-detail-item"><h4><a href="#" class="glossary-link" data-term-key="${this.escapeHTML(t.name)}">${this.escapeHTML(t.name)} ${f}</a><span class="trait-score-badge">Score: ${s??'N/A'}</span></h4><p>${this.escapeHTML(d)}</p></div>`;}); c+='</div>';} c+='</section>'; const h=this.getSynergyHints(person); if(h.length>0){c+='<section><h3>✨ Synergies ✨</h3><ul>'; h.forEach(hi=>{c+=`<li>${hi.type==='positive'?'➕':'🤔'} ${this.escapeHTML(hi.text)}</li>`;}); c+='</ul></section>';} console.log(`[RENDER_TRAIT_DETAILS] Fin.`); return c; }
  renderStyleBreakdownDetail(person) { console.log(`[RENDER_STYLE_BREAKDOWN] P ${person.id}, S ${person.style}`); let c='<section>'; if(person.role&&person.style&&person.traits){let b; try{if(person.role==='submissive')b=getSubBreakdown(person.style,person.traits); else if(person.role==='dominant')b=getDomBreakdown(person.style,person.traits); else b={strengths:"Varies for Switches.",improvements:"Communicate leaning."}; if(b){c+=`<h3>📊 ${this.escapeHTML(person.style)}</h3><div class="style-breakdown"><h4>Expressions:</h4><p class="strengths">${b.strengths}</p><h4>Exploration:</h4><p class="improvements">${b.improvements}</p></div>`;} else{c+='<p>Cannot generate.</p>';}}catch(e){console.error(`[RENDER_STYLE_BREAKDOWN] Err:`,e); c+=`<p class="error-text">Error.</p>`;}}else{c+='<p>Need Role/Style/Traits.</p>';} c+='</section>'; console.log(`[RENDER_STYLE_BREAKDOWN] Fin.`); return c;}
  renderHistoryTab(person) { console.log(`[RENDER_HISTORY_TAB] P ${person.id}`); const sn=person.history||[]; let c=`<section id="tab-history-content"><h3>📈 History</h3>`; c+=`<div class="modal-actions"><button type="button" id="snapshot-btn" class="save-btn small-btn">Snapshot 📸</button></div>`; if(sn.length===0)c+=`<p>No snapshots.</p>`; else if(sn.length<2)c+=`<p>Need 2+ for chart.</p>`; else c+=`<div class="history-chart-container"><canvas id="history-chart"></canvas></div>`; if(sn.length>0){c+='<h4>Recent:</h4><ul class="snapshot-list">'; sn.slice(-5).reverse().forEach((s)=>{const d=new Date(s.timestamp).toLocaleString(); c+=`<li>${d} - <button type="button" class="link-button snapshot-toggle" onclick="window.kinkCompassApp.toggleSnapshotInfo(this)">Traits</button>`; c+='<div class="snapshot-details" style="display:none;"><ul>'; if(s.traits){for(const t in s.traits){c+=`<li>${this.escapeHTML(t)}: ${s.traits[t]}</li>`;}}else{c+=`<li>No data.</li>`;} c+='</ul></div></li>';}); c+='</ul>'; if(sn.length>5)c+='<p>(Last 5)</p>';} c+='</section>'; console.log(`[RENDER_HISTORY_TAB] Fin HTML.`); return c; }
  renderJournalTab(person) { console.log(`[RENDER_JOURNAL_TAB] P ${person.id}`); let c=`<section><h3>📝 Journal</h3><div class="modal-actions"><button type="button" id="journal-prompt-btn" class="small-btn">Prompt 🤔</button></div><div id="journal-prompt-area" class="journal-prompt" style="display:none;"></div><textarea id="reflections-textarea" class="reflections-textarea" placeholder="Reflect..." aria-label="Journal Entry">${this.escapeHTML(person.reflections||'')}</textarea><div class="modal-actions"><button type="button" id="save-reflections-btn" class="save-btn">Save 💾</button></div></section>`; const gh=this.getGoalAlignmentHints(person); if(gh.length>0){c+=`<section><h3>🎯 Goal Align Hints</h3><ul>`; gh.forEach(h=>{c+=`<li>${this.escapeHTML(h)}</li>`;}); c+=`</ul></section>`;} console.log(`[RENDER_JOURNAL_TAB] Fin.`); return c; }
  renderOracleTab(person) { /* Rendered within renderInsightsTab */ return ''; } // No longer directly rendered
  renderAchievementsList(person = null) { const tid=person?`achievements-list-${person.id}`:'all-achievements-list'; /*console.log(`[RENDER_ACH] For ${person?'P '+person.id:'All'}. Tgt: ${tid}`);*/ let lh=''; const ak=Object.keys(achievementList); if(ak.length===0)return '<p>None defined.</p>'; ak.sort((a,b)=>achievementList[a].name.localeCompare(achievementList[b].name)).forEach(k=>{const a=achievementList[k]; if(!a)return; const iu=person?hasAchievement(person,k):false; const sc=person?(iu?'unlocked':'locked'):''; const i=iu?'🏆':(person?'🔒':'🏅'); const n=a.name||'Unnamed'; const d=person?(iu?a.desc:'Keep exploring!'):a.desc; lh+=`<li class="${sc}"><span class="achievement-icon">${i}</span><div class="achievement-details"><span class="achievement-name">${this.escapeHTML(n)}</span><span class="achievement-desc">${this.escapeHTML(d)}</span></div></li>`;}); /*console.log(`[RENDER_ACH] Gen HTML.`);*/ if(person)return `<section><h3>🏆 Achievements</h3><ul class="achievements-section-list">${lh}</ul></section>`; else return `<ul id="${tid}" class="all-achievements-list">${lh}</ul>`; }
  renderGoalList(person, returnListOnly = false) { console.log(`[RENDER_GOAL_LIST] P ${person.id}. ListOnly: ${returnListOnly}`); const g=person.goals||[]; let lh='<ul id="goal-list">'; if(g.length===0)lh+='<li>No goals.</li>'; else { g.sort((a,b)=>(a.done===b.done)?0:a.done?1:-1).forEach(gl=>{const iD=gl.done; lh+=`<li class="${iD?'done':''}" data-goal-id="${gl.id}"><span>${this.escapeHTML(gl.text)}</span><div class="goal-actions"><button type="button" class="small-btn toggle-goal-btn" data-goal-id="${gl.id}">${iD?'Undo':'Done'}</button><button type="button" class="small-btn delete-btn delete-goal-btn" data-goal-id="${gl.id}" aria-label="Delete">🗑️</button></div></li>`;});} lh+='</ul>'; if(returnListOnly){console.log(`[RENDER_GOAL_LIST] List only.`); return lh;} const fc=`<section><h3>🎯 Goals</h3><div id="goal-list-container">${lh}</div><hr><h4>Add New:</h4><form id="add-goal-form" class="add-goal-form" action="#"><input type="text" placeholder="Practice..." required aria-label="New goal"><button type="submit" id="add-goal-btn" class="small-btn save-btn">Add</button></form></section>`; console.log(`[RENDER_GOAL_LIST] Full tab.`); return fc; }

  // --- New Feature Logic --- (Keep Functions as they were, ensuring fixes are present)
  addGoal(personId, formElement) { /* ... */ console.log(`[ADD_GOAL] START - P ${personId}`); if(!formElement){console.error("No form.");return;} const i=formElement.querySelector('input[type="text"]'); if(!i){console.error("No input.");return;} const gt=i.value.trim(); if(!gt){this.showNotification("Enter goal.", "warning"); i.focus();return;} const p=this.people.find(pr=>pr.id===personId); if(!p){console.error(`Person ${personId} not found.`); this.showNotification("Error.", "error");return;} if(!p.goals) p.goals=[]; const ng={id:Date.now(),text:gt,done:false,createdAt:new Date().toISOString()}; p.goals.push(ng); this.saveToLocalStorage(); this.showNotification("Goal added!", "success"); grantAchievement(p,'goal_added'); console.log("Success:",ng); const glc=document.querySelector('#tab-goals-journal-content #goal-list-container'); if(glc&&this.activeDetailModalTab==='tab-goals-journal'){console.log("Re-render list."); glc.innerHTML=this.renderGoalList(p,true);} i.value=''; console.log("[ADD_GOAL] END"); }
  toggleGoalStatus(personId, goalId, listItemElement = null) { /* ... (Keep function with brace fix) ... */ console.log(`[TOGGLE_GOAL] START - G ${goalId}, P ${personId}`); const p=this.people.find(pr=>pr.id===personId); if(!p?.goals){console.error("Fail: Person/goals."); this.showNotification("Error.", "error");return;} const gi=p.goals.findIndex(g=>g.id===goalId); if(gi===-1){console.error(`Fail: Goal ${goalId} missing.`); this.showNotification("Error.", "error");return;} p.goals[gi].done=!p.goals[gi].done; const iD=p.goals[gi].done; p.goals[gi].completedAt=iD?new Date().toISOString():null; this.saveToLocalStorage(); this.showNotification(iD?"Complete! 🎉":"Incomplete.",iD?'success':'info'); if(iD){grantAchievement(p,'goal_completed'); const cc=p.goals.filter(g=>g.done).length; if(cc>=5) grantAchievement(p,'five_goals_completed'); this.checkGoalStreak(p);} console.log(`Goal ${goalId} status: ${iD}`); if(listItemElement){console.log("Update UI direct."); listItemElement.classList.toggle('done',iD); const b=listItemElement.querySelector('.toggle-goal-btn'); if(b)b.textContent=iD?'Undo':'Done'; if(iD){const s=listItemElement.querySelector('span:first-child'); if(s){s.classList.add('goal-completed-animation'); setTimeout(()=>s.classList.remove('goal-completed-animation'),600);}}}else{console.log("No list item."); const glc=document.querySelector('#tab-goals-journal-content #goal-list-container'); if(glc&&this.activeDetailModalTab==='tab-goals-journal'){console.log("Re-render list."); glc.innerHTML=this.renderGoalList(p,true);}} console.log("[TOGGLE_GOAL] END"); }
  deleteGoal(personId, goalId) { /* ... Full function ... */ console.log(`[DELETE_GOAL] START - G ${goalId}, P ${personId}`); const p=this.people.find(pr=>pr.id===personId); if(!p?.goals){console.error("Fail: Person/goals missing."); this.showNotification("Error.", "error");return;} const il=p.goals.length; p.goals=p.goals.filter(g=>g.id!==goalId); if(p.goals.length<il){this.saveToLocalStorage(); this.showNotification("Goal deleted.", "info"); console.log("Success."); const glc=document.querySelector('#tab-goals-journal-content #goal-list-container'); if(glc&&this.activeDetailModalTab==='tab-goals-journal'){console.log("Re-render list."); glc.innerHTML=this.renderGoalList(p,true);}}else{console.error(`Fail: Goal ${goalId} missing.`); this.showNotification("Error.", "error");} console.log("[DELETE_GOAL] END"); }
  showJournalPrompt(personId) { /* ... Full function ... */ console.log(`[JOURNAL_PROMPT] P ${personId}`); const pa=document.getElementById('journal-prompt-area'); if(!pa){console.warn("Area missing.");return;} try{const pr=getRandomPrompt(); pa.textContent=pr; pa.style.display='block'; console.log(`Prompt: ${pr}`); const p=this.people.find(ps=>ps.id===personId); if(p)grantAchievement(p,'prompt_used');}catch(e){console.error("Error:",e); pa.textContent="Error."; pa.style.display='block';} }
  saveReflections(personId) { /* ... Full function ... */ console.log(`[SAVE_REFLECTIONS] START - P ${personId}`); const ta=document.getElementById('reflections-textarea'); if(!ta){console.error("Textarea missing."); this.showNotification("UI Error.", "error");return;} const p=this.people.find(ps=>ps.id===personId); if(!p){console.error(`Person ${personId} missing.`); this.showNotification("Error: Persona missing.", "error");return;} p.reflections=ta.value; p.lastUpdated=new Date().toISOString(); this.saveToLocalStorage(); this.showNotification("Saved!", "success"); grantAchievement(p,'reflection_saved'); const ec=(p.history?.filter(h=>h.type==='reflection').length||0)+1; if(ec>=5)grantAchievement(p,'five_reflections'); if(ec>=10)grantAchievement(p,'journal_journeyman'); ta.classList.add('input-just-saved'); setTimeout(()=>ta.classList.remove('input-just-saved'),1500); console.log("[SAVE_REFLECTIONS] END."); }
  addSnapshotToHistory(personId) { /* ... Full function ... */ console.log(`[ADD_SNAPSHOT] START - P ${personId}`); const p=this.people.find(ps=>ps.id===personId); if(!p?.traits){console.error("Fail: Person/traits missing."); this.showNotification("Error snapshotting.", "error");return;} if(!p.history)p.history=[]; const ns={timestamp:new Date().toISOString(),traits:{...p.traits}}; this.checkTraitTransformation(p,ns); this.checkConsistentSnapper(p,ns.timestamp); p.history.push(ns); p.lastUpdated=ns.timestamp; this.saveToLocalStorage(); this.showNotification("Snapshot saved! 📸", "success"); grantAchievement(p,'history_snapshot'); if(p.history.length>=10)grantAchievement(p,'ten_snapshots'); console.log("Added:",ns); const htc=document.querySelector('#tab-history-content'); if(htc&&this.activeDetailModalTab==='tab-history'){console.log("Re-render history tab."); this.renderDetailTabContent(p,'tab-history',htc); if(p.history.length>=2){setTimeout(()=>{console.log("Delayed chart render."); this.renderHistoryChart(p,'history-chart');},150);}} console.log("[ADD_SNAPSHOT] END"); }
  renderHistoryChart(person, canvasId) { /* ... Full function ... */ console.log(`[RENDER_HISTORY_CHART] START - P ${person.id}, C ${canvasId}`); const ce=document.getElementById(canvasId); const c=ce?.parentElement; if(!ce){console.warn(`Canvas ${canvasId} missing.`); if(c)c.innerHTML='<p>Chart canvas missing.</p>'; return;} if(!c)console.warn(`Container missing.`); if(!person?.history||person.history.length<2){console.log("<2 points."); if(c)c.innerHTML='<p>Need 2+ snapshots.</p>'; else ce.style.display='none'; return;} if(typeof Chart==='undefined'){console.error("Chart.js missing!"); if(c)c.innerHTML='<p>Charting library failed.</p>'; return;} if(c)c.classList.add('chart-loading'); ce.style.visibility='hidden'; console.log(`Points: ${person.history.length}`); const hd=person.history; const l=hd.map(s=>new Date(s.timestamp).toLocaleDateString()); const atn=[...new Set(hd.flatMap(s=>Object.keys(s.traits||{})))]; console.log("Traits:",atn); const dss=atn.map((tn,i)=>{const dp=hd.map(s=>s.traits?.[tn]??null); const h=(i*(360/Math.max(1,atn.length)))%360; const cl=`hsl(${h}, 70%, 60%)`; return{label:tn,data:dp,borderColor:cl,backgroundColor:cl+'30',tension:0.1,spanGaps:true,pointRadius:3,pointHoverRadius:6};}); if(this.chartInstance){console.log("Destroying previous."); this.chartInstance.destroy(); this.chartInstance=null;} requestAnimationFrame(()=>{try{const ctx=ce.getContext('2d'); console.log("Creating Chart."); this.chartInstance=new Chart(ctx,{type:'line',data:{labels:l,datasets:dss},options:{responsive:true,maintainAspectRatio:false,scales:{y:{beginAtZero:true,suggestedMax:5.5,title:{display:true,text:'Score'},grid:{color:getComputedStyle(document.body).getPropertyValue('--chart-grid-color')||'rgba(0,0,0,0.1)'}},x:{title:{display:true,text:'Date'},grid:{display:false}}},plugins:{legend:{position:'bottom',labels:{boxWidth:12}},tooltip:{mode:'index',intersect:false}},interaction:{mode:'nearest',axis:'x',intersect:false}}}); console.log("Chart created.");}catch(e){console.error("Error creating Chart:",e); if(c)c.innerHTML='<p>Chart error.</p>';}finally{if(c)c.classList.remove('chart-loading'); ce.style.visibility='visible';}}); console.log("[RENDER_HISTORY_CHART] END"); }
  toggleSnapshotInfo(button) { /* ... Full function ... */ console.log("[TOGGLE_SNAPSHOT_INFO] Click."); const dD=button.nextElementSibling; if(dD?.classList.contains('snapshot-details')){const iV=dD.style.display!=='none'; dD.style.display=iV?'none':'block'; button.textContent=iV?'View Traits':'Hide Traits'; console.log(`Visibility: ${!iV}`);} else {console.warn("Details div missing:",button);} }
  showAchievements() { /* ... Full function ... */ console.log("[SHOW_ACHIEVEMENTS] Opening."); const m=this.elements.achievementsModal, b=this.elements.achievementsBody; if(!m||!b){console.error("Fail: Modal/body missing."); this.showNotification("UI Error.","error"); return;} b.innerHTML=`<p>Explore milestones!</p>${this.renderAchievementsList(null)}`; this.openModal(m); console.log("Modal opened."); }
  showKinkOracle(personId) { /* ... Full function ... */ console.log(`[SHOW_KINK_ORACLE] P ${personId}`); const oE=document.getElementById('oracle-reading-output'); if(!oE){console.error("Output missing."); this.showNotification("UI Error.","error"); return;} const p=this.people.find(ps=>ps.id===personId); if(!p){console.error(`Person ${personId} missing.`); oE.innerHTML=`<p>Persona error.</p>`; return;} oE.innerHTML=`<p><i>Spinning...</i> ✨</p>`; setTimeout(()=>{try{const rD=this.getKinkOracleReading(p); if(!rD)throw new Error("No reading."); oE.innerHTML=`<p>${this.escapeHTML(rD.opening)}</p><p><strong>Focus:</strong> ${this.escapeHTML(rD.focus)}</p><p><em>${this.escapeHTML(rD.encouragement)}</em></p><p>${this.escapeHTML(rD.closing)}</p>`; console.log("Reading:",rD); grantAchievement(p,'kink_reading_oracle'); this.saveToLocalStorage();}catch(e){console.error("Oracle Error:",e); oE.innerHTML=`<p>Oracle silent.</p>`;}},500); }
  displayDailyChallenge() { /* ... Full function, uses area in renderInsightsTab or updateLivePreview ... */ console.log("[DAILY_CHALLENGE] Displaying."); const area=document.getElementById('daily-challenge-area'); if(!area){console.warn("Challenge area missing."); return;} try{const ch=this.getDailyChallenge(null); if(ch){area.innerHTML=`<h4 style="margin-bottom:0.5em;">🌟 Today's Focus 🌟</h4><h5>${this.escapeHTML(ch.title)}</h5><p>${this.escapeHTML(ch.desc)}</p><p class="muted-text"><small>(Cat: ${this.escapeHTML(ch.category)})</small></p>`; area.style.display='block'; console.log("Displayed:",ch); localStorage.setItem('kinkCompass_challenge_accepted','true');}else{console.log("No challenge."); area.innerHTML=''; area.style.display='none';}}catch(e){console.error("Challenge Error:",e); area.innerHTML=`<p>Challenge error.</p>`; area.style.display='block';} }

  // --- Glossary, Style Discovery --- (Keep Functions as they were)
  showGlossary(termKeyToHighlight = null) { console.log(`[SHOW_GLOSSARY] Open. Highlight: ${termKeyToHighlight}`); const modal = this.elements.glossaryModal, body = this.elements.glossaryBody; if (!modal || !body) { console.error("[SHOW_GLOSSARY] Fail: Modal/body missing."); this.showNotification("UI Error.", "error"); return; } body.innerHTML = ''; const sortedKeys = Object.keys(glossaryTerms).sort((a, b) => glossaryTerms[a].term.localeCompare(glossaryTerms[b].term)); if (sortedKeys.length === 0) { body.innerHTML = '<p>Glossary empty.</p>'; } else { const dl = document.createElement('dl'); sortedKeys.forEach(key => { const termData = glossaryTerms[key]; if (!termData) return; const dt = document.createElement('dt'); dt.id = `glossary-${key}`; dt.textContent = termData.term; const dd = document.createElement('dd'); dd.textContent = termData.definition; if (termData.related?.length > 0) { const relatedP = document.createElement('p'); relatedP.className = 'related-terms'; relatedP.innerHTML = 'Related: '; termData.related.forEach((relatedKey, index) => { if (glossaryTerms[relatedKey]) { const link = document.createElement('a'); link.href = `#glossary-${relatedKey}`; link.textContent = glossaryTerms[relatedKey].term; link.classList.add('glossary-link'); link.dataset.termKey = relatedKey; relatedP.appendChild(link); if (index < termData.related.length - 1) relatedP.appendChild(document.createTextNode(', ')); } }); dd.appendChild(relatedP); } dl.appendChild(dt); dl.appendChild(dd); }); body.appendChild(dl); } this.openModal(modal); console.log("[SHOW_GLOSSARY] Modal opened."); if (termKeyToHighlight) { console.log(`[SHOW_GLOSSARY] Highlight/scroll: ${termKeyToHighlight}`); requestAnimationFrame(() => { const element = document.getElementById(`glossary-${termKeyToHighlight}`); if (element) { console.log("[SHOW_GLOSSARY] Found:", element); element.classList.add('highlighted-term'); element.scrollIntoView({ behavior: 'smooth', block: 'center' }); console.log("[SHOW_GLOSSARY] Scrolled."); setTimeout(() => { element.classList.remove('highlighted-term'); console.log(`[SHOW_GLOSSARY] Highlight removed.`); }, 2500); } else { console.warn(`[SHOW_GLOSSARY] Element ID not found: glossary-${termKeyToHighlight}`); } }); } }
  showStyleDiscovery(styleNameToHighlight = null) { console.log(`[STYLE_DISCOVERY] Open. Highlight: ${styleNameToHighlight}`); const modal = this.elements.styleDiscoveryModal, body = this.elements.styleDiscoveryBody, roleFilter = this.elements.styleDiscoveryRoleFilter; if (!modal || !body || !roleFilter) { console.error("[STYLE_DISCOVERY] Fail: Modal elements missing."); this.showNotification("UI Error.", "error"); return; } roleFilter.value = 'all'; console.log("[STYLE_DISCOVERY] Filter reset."); this.renderStyleDiscoveryContent(styleNameToHighlight); this.openModal(modal); console.log("[STYLE_DISCOVERY] Modal opened."); }
  renderStyleDiscoveryContent(styleNameToHighlight = null) { console.log(`[RENDER_STYLE_DISCOVERY] Render. Highlight: ${styleNameToHighlight}`); const body = this.elements.styleDiscoveryBody, roleFilter = this.elements.styleDiscoveryRoleFilter.value; console.log(`[RENDER_STYLE_DISCOVERY] Filter: ${roleFilter}`); if (!body) { console.error("[RENDER_STYLE_DISCOVERY] Fail: Body missing."); return; } body.innerHTML = '<p>Loading...</p>'; let stylesToDisplay = []; const rolesToInclude = roleFilter === 'all' ? ['submissive', 'dominant', 'switch'] : [roleFilter]; rolesToInclude.forEach(roleKey => { if (bdsmData[roleKey]?.styles) { stylesToDisplay.push(...bdsmData[roleKey].styles.map(style => ({ ...style, role: roleKey }))); } }); stylesToDisplay.sort((a, b) => a.name.localeCompare(b.name)); console.log(`[RENDER_STYLE_DISCOVERY] Found ${stylesToDisplay.length} styles.`); if (stylesToDisplay.length === 0) { body.innerHTML = '<p>No styles found.</p>'; return; } let contentHTML = ''; stylesToDisplay.forEach(style => { const styleKey = `style-discovery-${this.escapeHTML(style.role)}-${this.escapeHTML(style.name.replace(/[^a-zA-Z0-9]/g, '-'))}`; const breakdown = style.summary || "No summary."; const coreTraits = bdsmData[style.role]?.coreTraits?.map(t => t.name) || []; const styleTraits = style.traits?.map(t => t.name) || []; const allTraitNames = [...new Set([...coreTraits, ...styleTraits])]; contentHTML += `<div class="style-discovery-item" id="${styleKey}"><h4>${this.escapeHTML(style.name)} <small>(${this.escapeHTML(style.role)})</small></h4><p>${this.escapeHTML(breakdown)}</p>${allTraitNames.length > 0 ? `<p><small>Traits: ${allTraitNames.map(t => this.escapeHTML(t)).join(', ')}</small></p>` : ''}</div>`; }); body.innerHTML = contentHTML; console.log("[RENDER_STYLE_DISCOVERY] Rendered items."); if (styleNameToHighlight) { console.log(`[RENDER_STYLE_DISCOVERY] Highlight/scroll: ${styleNameToHighlight}`); requestAnimationFrame(() => { let elementToHighlight = null; const items = body.querySelectorAll('.style-discovery-item'); items.forEach(item => { const h4 = item.querySelector('h4'); if (h4 && h4.textContent.includes(styleNameToHighlight)) { elementToHighlight = item; } }); if (elementToHighlight) { console.log("[RENDER_STYLE_DISCOVERY] Found:", elementToHighlight); elementToHighlight.classList.add('highlighted-style'); elementToHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' }); console.log("[RENDER_STYLE_DISCOVERY] Scrolled."); setTimeout(() => { elementToHighlight.classList.remove('highlighted-style'); console.log(`[RENDER_STYLE_DISCOVERY] Highlight removed.`); }, 2500); } else { console.warn(`[RENDER_STYLE_DISCOVERY] Element not found: ${styleNameToHighlight}`); } }); } }

  // --- Data Import/Export --- (Keep Functions as they were)
  exportData() { console.log("[EXPORT_DATA] Start."); try { const dataStr = JSON.stringify({ people: this.people, version: "KinkCompass_v2.8" }, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const timestamp = new Date().toISOString().slice(0, 16).replace(/[:T]/g, '-'); link.download = `kinkcompass_backup_${timestamp}.json`; console.log(`[EXPORT_DATA] File: ${link.download}`); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); this.showNotification("Data exported!", "success"); grantAchievement({}, 'data_exported'); localStorage.setItem('kinkCompass_data_exported', 'true'); console.log("[EXPORT_DATA] END - Success."); } catch (error) { console.error("[EXPORT_DATA] Error:", error); this.showNotification("Export error.", "error"); } }
  importData(event) { console.log("[IMPORT_DATA] Start."); const file = event.target.files[0]; if (!file) { console.log("[IMPORT_DATA] No file."); return; } console.log(`[IMPORT_DATA] File: ${file.name}, Type: ${file.type}`); if (file.type !== 'application/json') { this.showNotification("File must be .json.", "error"); console.warn("[IMPORT_DATA] Wrong type."); event.target.value = null; return; } const reader = new FileReader(); reader.onload = (e) => { console.log("[IMPORT_DATA] File read."); try { const importedData = JSON.parse(e.target.result); console.log("[IMPORT_DATA] JSON parsed."); if (!importedData?.people || !Array.isArray(importedData.people)) throw new Error("Invalid format: Missing 'people' array."); if (!confirm(`Import ${importedData.people.length} personas? REPLACES current data.`)) { console.log("[IMPORT_DATA] Cancelled."); event.target.value = null; return; } console.log("[IMPORT_DATA] Confirmed."); this.people = importedData.people; console.log(`[IMPORT_DATA] Replaced data.`); this.people.forEach(p => { if (!p.id) p.id = Date.now() + Math.random(); if (!p.achievements) p.achievements = []; if (!p.goals) p.goals = []; if (!p.history) p.history = []; if (p.reflections === undefined) p.reflections = ""; }); this.saveToLocalStorage(); this.renderList(); this.resetForm(); this.showNotification("Data imported!", "success"); grantAchievement({}, 'data_imported'); localStorage.setItem('kinkCompass_data_imported', 'true'); console.log("[IMPORT_DATA] END - Success."); } catch (error) { console.error("[IMPORT_DATA] Error processing:", error); this.showNotification(`Import failed: ${error.message}.`, "error", 6000); } finally { event.target.value = null; console.log("[IMPORT_DATA] Input reset."); } }; reader.onerror = (e) => { console.error("[IMPORT_DATA] Reader error:", e); this.showNotification("Error reading file.", "error"); event.target.value = null; }; console.log("[IMPORT_DATA] Reading text..."); reader.readAsText(file); }

  // --- Popups --- (Keep Functions as they were)
  showTraitInfo(traitName) { console.log(`[SHOW_TRAIT_INFO] For: ${traitName}`); const popup = this.elements.traitInfoPopup, title = this.elements.traitInfoTitle, body = this.elements.traitInfoBody; if (!popup || !title || !body) { console.error("[SHOW_TRAIT_INFO] Fail: Popup elements missing."); return; } let explanation = `Details for '${traitName}' not found.`; let found = false; for (const roleKey in bdsmData) { const roleData = bdsmData[roleKey]; const coreTrait = roleData.coreTraits?.find(t => t.name === traitName); if (coreTrait?.explanation) { explanation = coreTrait.explanation; found = true; break; } const styleTrait = roleData.styles?.flatMap(s => s.traits || []).find(t => t.name === traitName); if (styleTrait?.explanation) { explanation = styleTrait.explanation; found = true; break; } } if (!found) console.warn(`[SHOW_TRAIT_INFO] Explanation missing for: ${traitName}`); title.textContent = `About: ${this.escapeHTML(traitName)}`; body.innerHTML = `<p>${this.escapeHTML(explanation)}</p>`; popup.style.display = 'block'; popup.setAttribute('aria-hidden', 'false'); this.elements.traitInfoClose?.focus(); console.log("[SHOW_TRAIT_INFO] Displayed."); grantAchievement({}, 'trait_info_viewed'); localStorage.setItem('kinkCompass_trait_info_viewed', 'true'); }
  hideTraitInfo() { console.log("[HIDE_TRAIT_INFO] Hiding."); const popup = this.elements.traitInfoPopup; if (!popup) return; popup.style.display = 'none'; popup.setAttribute('aria-hidden', 'true'); const triggerButton = document.querySelector('.trait-info-btn[aria-expanded="true"]'); if(triggerButton) { triggerButton.setAttribute('aria-expanded', 'false'); triggerButton.focus(); console.log("[HIDE_TRAIT_INFO] Focus returned."); } else { console.log("[HIDE_TRAIT_INFO] Trigger button not found."); } }
  showContextHelp(helpKey) { console.log(`[SHOW_CONTEXT_HELP] Key: ${helpKey}`); const popup = this.elements.contextHelpPopup, title = this.elements.contextHelpTitle, body = this.elements.contextHelpBody; const triggerButton = document.querySelector(`.context-help-btn[data-help-key="${helpKey}"]`); if (!popup || !title || !body) { console.error("[SHOW_CONTEXT_HELP] Fail: Popup elements missing."); return; } const helpText = contextHelpTexts[helpKey] || "No help available."; console.log(`[SHOW_CONTEXT_HELP] Text: ${helpText}`); title.textContent = `Help: ${this.escapeHTML(helpKey)}`; body.innerHTML = `<p>${this.escapeHTML(helpText)}</p>`; popup.style.display = 'block'; popup.setAttribute('aria-hidden', 'false'); this.elements.contextHelpClose?.focus(); document.querySelectorAll('.context-help-btn[aria-expanded="true"]').forEach(btn => { if (btn !== triggerButton) btn.setAttribute('aria-expanded', 'false'); }); if(triggerButton) triggerButton.setAttribute('aria-expanded', 'true'); console.log("[SHOW_CONTEXT_HELP] Displayed."); }
  hideContextHelp() { console.log("[HIDE_CONTEXT_HELP] Hiding."); const popup = this.elements.contextHelpPopup; if (!popup) return; popup.style.display = 'none'; popup.setAttribute('aria-hidden', 'true'); const triggerButton = document.querySelector('.context-help-btn[aria-expanded="true"]'); if(triggerButton) { triggerButton.setAttribute('aria-expanded', 'false'); triggerButton.focus(); console.log("[HIDE_CONTEXT_HELP] Focus returned."); } else { console.log("[HIDE_CONTEXT_HELP] Trigger button not found."); } }

  // --- Style Finder Methods --- (Keep Functions as they were, ensuring fixes are present and using imported data)
  sfStart() { /* ... */ } sfClose() { /* ... */ } sfCalculateSteps() { /* ... */ } sfRenderStep() { /* ... */ } sfSetRole(role) { /* ... */ } sfSetTrait(trait, value) { /* ... */ } sfNextStep(currentTrait = null) { /* ... (with interaction flag fix) ... */ console.log(`[SF_NEXT_STEP] From ${this.styleFinderStep}. Trait: ${currentTrait}`); const steps = this.sfCalculateSteps(); const currentStepData = steps[this.styleFinderStep]; if (currentStepData?.type === 'trait' && !this.sfSliderInteracted) { this.sfShowFeedback("Move slider!"); console.warn("[SF_NEXT_STEP] Fail: Not interacted for", currentTrait); const slider = this.elements.sfStepContent?.querySelector(`input[data-trait="${currentTrait}"]`); if(slider) { slider.classList.add('shake-animation'); setTimeout(() => slider.classList.remove('shake-animation'), 500); } return; } const totalSteps = steps.length; if (this.styleFinderStep < totalSteps - 1) { this.styleFinderStep++; console.log(`[SF_NEXT_STEP] To ${this.styleFinderStep}`); this.sfRenderStep(); } else { console.log("[SF_NEXT_STEP] Last step."); } } sfPrevStep() { /* ... */ } sfStartOver() { /* ... */ } sfComputeScores(temporary = false) { /* ... (with fix) ... */ let scores = {}; if (!this.styleFinderRole) return scores; const relevantStyles = sfStyles[this.styleFinderRole]; if (!relevantStyles) return scores; relevantStyles.forEach(style => { scores[style] = 0; }); const localStyleKeyTraits = sfStyleKeyTraits; Object.keys(this.styleFinderAnswers.traits).forEach(trait => { const rating = this.styleFinderAnswers.traits[trait] || 0; relevantStyles.forEach(style => { const keyTraitsForStyle = localStyleKeyTraits[style] || []; if (!keyTraitsForStyle && !temporary) console.warn(`[SF_COMPUTE_SCORES] Keys missing for: ${style}`); if (keyTraitsForStyle.includes(trait)) { scores[style] += rating; if (rating >= 9) scores[style] += 2; else if (rating <= 2) scores[style] -= 1; } }); }); let highestScore = 0; Object.values(scores).forEach(score => { if (score > highestScore) highestScore = score; }); if (highestScore > 0 && !temporary) { Object.keys(scores).forEach(style => { scores[style] = Math.max(0, (scores[style] / highestScore) * 100); }); } return scores; } sfUpdateDashboard(forceVisible = false) { /* ... */ } toggleStyleFinderDashboard() { /* ... */ } sfCalculateResult() { /* ... */ } sfGenerateSummaryDashboard(sortedSummaryScores) { /* ... */ } sfShowFeedback(message, type = 'info') { /* ... */ } sfShowTraitInfo(traitName, triggerElement = null) { /* ... */ } sfShowFullDetails(styleNameWithEmoji, triggerElement = null) { /* ... (with name cleaning fix) ... */ console.log(`[SF_SHOW_FULL_DETAILS] SF Style: ${styleNameWithEmoji}`); let styleName = styleNameWithEmoji.replace(/([\u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1FA70}-\u{1FAFF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{E0000}-\u{E007F}]+)/gu, '').trim(); console.log(`[SF_SHOW_FULL_DETAILS] Cleaned name: "${styleName}"`); const descData = sfStyleDescriptions[styleName]; const matchData = sfDynamicMatches[styleName]; if (!descData || !matchData) { console.error(`[SF_SHOW_FULL_DETAILS] Data missing for: "${styleName}"`); this.sfShowFeedback("Cannot load details.", "error"); return; } const existingPopup = document.querySelector('.sf-style-info-popup'); if(existingPopup) existingPopup.remove(); const popup = document.createElement('div'); popup.className = 'sf-style-info-popup card wide-popup'; popup.innerHTML = `<button class="sf-close-btn" onclick="this.parentElement.remove()" aria-label="Close">×</button><h3>${styleNameWithEmoji} Details</h3><h4>Summary</h4><p><strong>${this.escapeHTML(descData.short)}</strong></p><p>${this.escapeHTML(descData.long)}</p><h4>Match: ${this.getStyleIcons()[matchData.match] || ''} ${this.escapeHTML(matchData.match)}</h4><p><em>Dynamic: ${this.escapeHTML(matchData.dynamic)}</em></p><p>${this.escapeHTML(matchData.longDesc)}</p><h4>Tips:</h4><ul>${descData.tips.map(tip => `<li>${this.escapeHTML(tip)}</li>`).join('')}</ul>`; document.body.appendChild(popup); popup.querySelector('.sf-close-btn')?.focus(); if (triggerElement) triggerElement.classList.add('active'); console.log("[SF_SHOW_FULL_DETAILS] Popup displayed."); } getStyleIcons() { /* ... */ return { 'Submissive': '🙇', 'Brat': '😈', 'Slave': '🔗', 'Switch': '🔄', 'Pet': '🐾', 'Little': '🍼', 'Puppy': '🐶', 'Kitten': '🐱', 'Princess': '👑', 'Rope Bunny': '🪢', 'Masochist': '💥', 'Prey': '🏃', 'Toy': '🎲', 'Doll': '🎎', 'Bunny': '🐰', 'Servant': '🧹', 'Playmate': '🎉', 'Babygirl': '🌸', 'Captive': '⛓️', 'Thrall': '🛐', 'Puppet': '🎭', 'Maid': '🧼', 'Painslut': '🔥', 'Bottom': '⬇️', 'Dominant': '👤', 'Assertive': '💪', 'Nurturer': '🤗', 'Strict': '📏', 'Master': '🎓', 'Mistress': '👸', 'Daddy': '👨‍🏫', 'Mommy': '👩‍🏫', 'Owner': '🔑', 'Rigger': '🧵', 'Sadist': '😏', 'Hunter': '🏹', 'Trainer': '🏋️', 'Puppeteer': '🕹️', 'Protector': '🛡️', 'Disciplinarian': '✋', 'Caretaker': '🧡', 'Sir': '🎩', 'Goddess': '🌟', 'Commander': '⚔️' }; }
    confirmApplyStyleFinderResult(role, styleWithEmoji) { /* ... */ console.log(`[SF_CONFIRM_APPLY] Confirm apply Role: ${role}, Style: ${styleWithEmoji}`); if (confirm(`Apply Role '${role}' and Style '${styleWithEmoji}' to form? Clears current form.`)) { console.log("[SF_CONFIRM_APPLY] Confirmed."); this.applyStyleFinderResult(role, styleWithEmoji); } else { console.log("[SF_CONFIRM_APPLY] Cancelled."); } }
    applyStyleFinderResult(role, styleWithEmoji) { /* ... */ console.log(`[SF_APPLY_RESULT] Applying Role: ${role}, Style: ${styleWithEmoji}`); if (!role || !styleWithEmoji || !this.elements.role || !this.elements.style || !this.elements.formSection) { console.error("[SF_APPLY_RESULT] Fail: Missing data/elements."); this.showNotification("Error applying.", "error"); return; } this.elements.role.value = role; this.renderStyles(role); this.elements.style.value = styleWithEmoji; this.renderTraits(role, styleWithEmoji); this.updateLivePreview(); this.updateStyleExploreLink(); this.sfClose(); this.showNotification(`Style '${styleWithEmoji}' applied!`, "success"); console.log("[SF_APPLY_RESULT] Applied & closed."); this.elements.formSection.scrollIntoView({ behavior: 'smooth' }); this.elements.name.focus(); }

  // --- Other Helper Functions --- (Keep Functions as they were)
  getFlairForScore(s) { const score = parseInt(s); if(isNaN(score)) return ''; if(score === 5) return '🌟'; if(score === 4) return '✨'; if(score === 3) return '👍'; if(score === 2) return '🌱'; if(score === 1) return '💧'; return ''; }
  getEmojiForScore(s) { return this.getFlairForScore(s); }
  escapeHTML(str) { if (typeof str !== 'string') return ''; return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); }
  getIntroForStyle(styleName){ const intro = bdsmData.submissive?.styles?.find(s => s.name === styleName)?.intro || bdsmData.dominant?.styles?.find(s => s.name === styleName)?.intro || bdsmData.switch?.styles?.find(s => s.name === styleName)?.intro || null; return intro; }
  showNotification(message, type = 'info', duration = 4000) { const n = document.getElementById('app-notification') || this.createNotificationElement(); if (!n) return; n.className = `notification-${type}`; n.textContent = message; n.style.opacity = '1'; n.style.top = '70px'; n.setAttribute('aria-hidden', 'false'); n.setAttribute('role', 'alert'); if (this.notificationTimer) clearTimeout(this.notificationTimer); this.notificationTimer = setTimeout(() => { n.style.opacity = '0'; n.style.top = '20px'; n.setAttribute('aria-hidden', 'true'); this.notificationTimer = null; }, duration); }
  createNotificationElement() { console.log("[CREATE_NOTIFICATION_ELEMENT] Creating."); try { const d = document.createElement('div'); d.id = 'app-notification'; d.setAttribute('aria-live', 'assertive'); d.setAttribute('aria-hidden', 'true'); document.body.appendChild(d); return d; } catch (error) { console.error("[CREATE_NOTIFICATION_ELEMENT] Failed:", error); return null; } }

  // --- Theme Management --- (Keep Functions as they were)
  applySavedTheme() { console.log("[APPLY_THEME] Apply saved."); const savedTheme = localStorage.getItem('kinkCompassTheme') || 'light'; console.log(`[APPLY_THEME] Saved: ${savedTheme}`); this.setTheme(savedTheme); }
  setTheme(themeName) { console.log(`[SET_THEME] Setting: ${themeName}`); document.documentElement.setAttribute('data-theme', themeName); localStorage.setItem('kinkCompassTheme', themeName); if (this.elements.themeToggle) { this.elements.themeToggle.textContent = themeName === 'light' ? '🌙' : '☀️'; this.elements.themeToggle.setAttribute('aria-label', themeName === 'light' ? 'To Dark' : 'To Light'); } grantAchievement({}, 'theme_changer'); localStorage.setItem('kinkCompass_theme_changer', 'true'); console.log(`[SET_THEME] Applied: ${themeName}`); }
  toggleTheme() { console.log("[TOGGLE_THEME] Toggle."); const currentTheme = document.documentElement.getAttribute('data-theme') || 'light'; const newTheme = currentTheme === 'light' ? 'dark' : 'light'; console.log(`[TOGGLE_THEME] New: ${newTheme}`); this.setTheme(newTheme); }

   // --- Modal Management --- (Keep Functions as they were)
   openModal(modalElement) { if (!modalElement) { console.error("[OPEN_MODAL] Fail: Null element."); return; } const modalId = modalElement.id || 'unknown_modal'; console.log(`[OPEN_MODAL] Open: #${modalId}`); const currentlyOpen = document.querySelector('.modal[aria-hidden="false"]'); if (currentlyOpen && currentlyOpen !== modalElement) { console.log(`[OPEN_MODAL] Closing other: #${currentlyOpen.id}`); this.closeModal(currentlyOpen); } this.elementThatOpenedModal = document.activeElement; console.log(`[OPEN_MODAL] Stored focus return:`, this.elementThatOpenedModal); modalElement.setAttribute('aria-hidden', 'false'); modalElement.style.display = 'flex'; console.log(`[OPEN_MODAL] Displayed #${modalId}`); requestAnimationFrame(() => { let focusTarget = modalElement.querySelector('.modal-close, input:not([type="hidden"]), select, textarea, button, [href]'); if (!focusTarget) { modalElement.setAttribute('tabindex', '-1'); focusTarget = modalElement; } if (focusTarget) { try { focusTarget.focus(); console.log(`[OPEN_MODAL] Focused in #${modalId}:`, focusTarget); } catch (focusError) { console.error(`[OPEN_MODAL] Error focusing:`, focusError, focusTarget); try { modalElement.setAttribute('tabindex', '-1'); modalElement.focus(); console.log(`[OPEN_MODAL] Fallback focus.`); } catch (fallbackError) { console.error(`[OPEN_MODAL] Fallback error:`, fallbackError); } } } else { console.warn(`[OPEN_MODAL] No focusable element.`); } }); }
   closeModal(modalElement) { if (!modalElement) { console.error("[CLOSE_MODAL] Fail: Null element."); return; } const modalId = modalElement.id || 'unknown_modal'; console.log(`[CLOSE_MODAL] Close: #${modalId}`); modalElement.setAttribute('aria-hidden', 'true'); modalElement.style.display = 'none'; console.log(`[CLOSE_MODAL] Hid #${modalId}`); modalElement.removeAttribute('tabindex'); const elementToFocus = this.elementThatOpenedModal; this.elementThatOpenedModal = null; requestAnimationFrame(() => { try { if (elementToFocus?.focus && document.body.contains(elementToFocus)) { elementToFocus.focus(); console.log("[CLOSE_MODAL] Focus restored:", elementToFocus); } else { console.warn("[CLOSE_MODAL] Focus element invalid. Focus body."); document.body.focus(); } } catch (e) { console.error("[CLOSE_MODAL] Focus restore error:", e); try { document.body.focus(); } catch (e2) { console.error("[CLOSE_MODAL] Body focus error:", e2); } } }); console.log(`[CLOSE_MODAL] Finished closing #${modalId}.`); }

   // <<< --- HELPER FUNCTIONS --- >>> (Keep Functions as they were)
    getSynergyHints(person) { if (!person?.traits || typeof synergyHints !== 'object') return []; const hints = []; const traitScores = person.traits; const highTraits = Object.entries(traitScores).filter(([, score]) => score >= 4).map(([name]) => name); const lowTraits = Object.entries(traitScores).filter(([, score]) => score <= 2).map(([name]) => name); synergyHints.highPositive?.forEach((synergy) => { if (synergy.traits?.every((trait) => highTraits.includes(trait))) { hints.push({ type: 'positive', text: synergy.hint }); } }); synergyHints.interestingDynamics?.forEach((dynamic) => { if (dynamic.traits?.high && dynamic.traits?.low && highTraits.includes(dynamic.traits.high) && lowTraits.includes(dynamic.traits.low)) { hints.push({ type: 'dynamic', text: dynamic.hint }); } }); return hints; }
    getGoalAlignmentHints(person) { const hints = []; if (!person?.goals || !person?.traits || typeof goalKeywords !== 'object') return hints; const activeGoals = person.goals.filter(g => !g.done); activeGoals.slice(0, 5).forEach(goal => { const goalTextLower = goal.text.toLowerCase(); Object.entries(goalKeywords).forEach(([keyword, data]) => { if (goalTextLower.includes(keyword)) { data.relevantTraits?.forEach(traitName => { if (person.traits.hasOwnProperty(traitName)) { const score = person.traits[traitName]; const promptTemplate = data.promptTemplates?.[Math.floor(Math.random() * data.promptTemplates.length)]; if(promptTemplate) { const hintText = promptTemplate.replace('{traitName}', traitName); hints.push(`For goal "${goal.text}": ${hintText} (Your ${traitName} score: ${score})`); } } }); } }); }); const uniqueHints = [...new Set(hints)]; return uniqueHints.slice(0, 3); }
    getDailyChallenge(persona = null) { if (typeof challenges !== 'object') { console.error("[GET_DAILY_CHALLENGE] Fail: Data missing."); return null; } let possibleCategories = ['communication', 'exploration']; if (persona?.role) { const roleKey = persona.role.toLowerCase(); if (challenges[`${roleKey}_challenges`]) { possibleCategories.push(`${roleKey}_challenges`); } } if (possibleCategories.length === 0) { console.warn("[GET_DAILY_CHALLENGE] No categories."); return null; } const randomCategoryKey = possibleCategories[Math.floor(Math.random() * possibleCategories.length)]; const categoryChallenges = challenges[randomCategoryKey]; if (!categoryChallenges?.length) { console.warn(`[GET_DAILY_CHALLENGE] No challenges in: ${randomCategoryKey}`); const generalChallenges = challenges['communication'] || challenges['exploration']; if(generalChallenges?.length) { const fallback = generalChallenges[Math.floor(Math.random() * generalChallenges.length)]; return { ...fallback, category: 'General Fallback' }; } return null; } const randomChallenge = categoryChallenges[Math.floor(Math.random() * categoryChallenges.length)]; return { ...randomChallenge, category: randomCategoryKey.replace('_challenges', '') }; }
    getKinkOracleReading(person) { console.log(`[GET_ORACLE_READING] P ${person?.id}`); if (typeof oracleReadings !== 'object' || !oracleReadings.openings || !oracleReadings.focusAreas || !oracleReadings.encouragements || !oracleReadings.closings) { console.error("[GET_ORACLE_READING] Fail: Data missing."); return null; } const reading = {}; try { reading.opening = oracleReadings.openings[Math.floor(Math.random() * oracleReadings.openings.length)]; let focusText = ""; const traits = person?.traits ? Object.entries(person.traits).filter(([, score]) => !isNaN(parseInt(score)) && score >= 1 && score <= 5) : []; if (traits.length > 0 && Math.random() > 0.3) { traits.sort((a, b) => Math.abs(a[1] - 3) > Math.abs(b[1] - 3) ? -1 : 1); const focusTrait = traits[Math.floor(Math.random() * Math.min(traits.length, 3))]; if (focusTrait) { const traitName = focusTrait[0]; const template = oracleReadings.focusAreas.traitBased[Math.floor(Math.random() * oracleReadings.focusAreas.traitBased.length)]; focusText = template.replace('{traitName}', traitName); console.log(` -> Focus: Trait ${traitName}`); } } if (!focusText && person?.style && Math.random() > 0.5) { const template = oracleReadings.focusAreas.styleBased[Math.floor(Math.random() * oracleReadings.focusAreas.styleBased.length)]; focusText = template.replace('{styleName}', person.style); console.log(` -> Focus: Style ${person.style}`); } if (!focusText) { focusText = oracleReadings.focusAreas.general[Math.floor(Math.random() * oracleReadings.focusAreas.general.length)]; console.log(` -> Focus: General`); } reading.focus = focusText; reading.encouragement = oracleReadings.encouragements[Math.floor(Math.random() * oracleReadings.encouragements.length)]; reading.closing = oracleReadings.closings[Math.floor(Math.random() * oracleReadings.closings.length)]; console.log("[GET_ORACLE_READING] Success:", reading); return reading; } catch (error) { console.error("[GET_ORACLE_READING] Error:", error); return null; } }

   // --- Achievement Checkers --- (Keep Functions as they were)
    checkGoalStreak(person) { if (!person?.goals) return; const completedGoals = person.goals.filter(g => g.done && g.completedAt).sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt)); if (completedGoals.length < 3) return; const now = new Date(); const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); const recentCompletions = completedGoals.slice(0, 3).filter(g => new Date(g.completedAt) >= sevenDaysAgo); if (recentCompletions.length >= 3) { console.log(` -> Goal streak met!`); if(grantAchievement(person, 'goal_streak_3')) { this.showNotification("Achieved: Goal Streak! 🔥", "achievement"); this.saveToLocalStorage(); } } }
    checkTraitTransformation(person, currentSnapshot) { if (!person?.history?.length || !currentSnapshot?.traits) { return; } const previousSnapshot = person.history[person.history.length - 1]; if (!previousSnapshot?.traits) { return; } let transformed = false; for (const traitName in currentSnapshot.traits) { if (previousSnapshot.traits.hasOwnProperty(traitName)) { const currentScore = parseInt(currentSnapshot.traits[traitName], 10); const previousScore = parseInt(previousSnapshot.traits[traitName], 10); if (!isNaN(currentScore) && !isNaN(previousScore) && currentScore - previousScore >= 2) { console.log(` -> Trait '${traitName}' transformed!`); transformed = true; break; } } } if (transformed) { if(grantAchievement(person, 'trait_transformer')) { this.showNotification("Achieved: Trait Transformer! ✨", "achievement"); } } }
    checkConsistentSnapper(person, currentTimestamp) { if (!person?.history?.length) { return; } const previousSnapshot = person.history[person.history.length - 1]; if (!previousSnapshot?.timestamp) { return; } const prevTime = new Date(previousSnapshot.timestamp); const currentTime = new Date(currentTimestamp); const daysDiff = (currentTime.getTime() - prevTime.getTime()) / (1000 * 60 * 60 * 24); if (daysDiff >= 3) { console.log(` -> Consistent snapper met!`); if(grantAchievement(person, 'consistent_snapper')) { this.showNotification("Achieved: Consistent Chronicler! 📅", "achievement"); } } }


} // <<< FINAL CLASS BRACE

// --- Initialization ---
try {
    console.log("[INIT] SCRIPT END: Initializing KinkCompass App...");
    window.kinkCompassApp = new TrackerApp();
    console.log("[INIT] SCRIPT END: KinkCompass App Initialized Successfully on window.kinkCompassApp");
} catch (error) {
    console.error("[INIT] FATAL error during App initialization:", error);
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = 'color: white; padding: 20px; border: 3px solid darkred; margin: 20px auto; background: red; font-family: monospace; white-space: pre-wrap; z-index: 9999; position: fixed; top: 10px; left: 10px; right: 10px; max-width: 80%; max-height: 50vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.5);';
    errorDiv.innerHTML = `<strong>FATAL ERROR: KinkCompass could not start.</strong><br><br>Message: ${error.message}<br><br>Stack Trace:<br>${error.stack || 'Not available'}`;
    document.body.prepend(errorDiv);
}
